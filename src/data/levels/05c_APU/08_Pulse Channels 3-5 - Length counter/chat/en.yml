---
main:
  messages:
  - "Pulse Channels can be silenced in two situations:"
  - 🔇  when games mute the channel with a 🎛️  APUControl write
  - 📏  when the length counter is 0
  - "constant volume y volumeOrEnvelopePeriod == 0 `// TODO: FINISH`"
  - con volume envelope y envelope.volume == 0
  - con frequency sweep.mute
  responses:
  - and what's a length counter? [length]

length:
  messages:
  - it's what the APU uses to track the <length> of the notes!
  - games <load> its initial value to indicate the note length
  - then that value is decreased every half frame
  - and when it reaches 0, the channel is muted! 🤐
  responses:
  - (k) how would a game load its value? [load]
  - (k) does it always decrement its value on half frames? [decrement]
  - (l) let's code it [exercise]

load:
  messages:
  - it writes to a register that has <Length Counter Load> (or it's abbreviated form, <LCL>) in its name
  - in the case of the Pulse Channels, it's 🕛  PulseTimerHighLCL, where the high 5 bits are the <length index>
  - that index points to a fixed table with all the available lengths, check out 📄  ~/lib/apu/noteLengths.js~
  responses:
  - what if a game needs a length that isn't in the list? [otherlengths]

otherlengths:
  messages:
  - that's not possible!
  - at least with this type of length counters
  responses:
  - ...length

decrement:
  messages:
  - only if its <halt flag> is not set
  - that would be the <L> bit in 🟦  PulseControl
  responses:
  - ...length

exercise:
  messages:
  - |-
    📚  create a 📏  `LengthCounter` class with the following:
    **constructor()**:
      **->** sets ```javascript this.counter = 0```
    **reset()**:
      **->** sets ```javascript this.counter = 0```
        (yeah, same as the constructor)
    **isActive()**:
      **->** returns whether ```javascript this.counter``` is greater than 0 or not
    **clock(isEnabled, isHalted)**:
      **->** if `!isEnabled`:
        **->** calls ```javascript this.reset()```
      **->** else:
        **->** if ```javascript this.isActive()``` and `!isHalted`:
          **->** decrements the counter
  - |-
    📚  in 🟦  `PulseChannel`:
    **->** import that class and add a `lengthCounter` property with a new instance
    **->** modify **sample()**, so if ```javascript !this.isEnabled()``` or the length counter is not active, it returns the last generated sample, without changing anything
    **->** add the methods described below
    **quarterFrame()**:
      **[!]** leave empty for now
    **halfFrame()**:
      **->** call the `clock(...)` method of the length counter
        (use ```javascript this.isEnabled()``` as the first argument)
        (for the halt flag, look for `envelopeLoopOrLengthCounterHalt` in the 🟦  PulseControl register)
  - |-
    📚  in 🔊  `APU`:
    **onQuarterFrameClock()**:
      **->** call `quarterFrame()` on the two pulse channel instances
    **onHalfFrameClock()**:
      **->** call `halfFrame()` on the two pulse channel instances
  - |-
    📚  implement in 🕛  `PulseTimerHighLCL`:
    **onLoad()**:
      **->** uses ```javascript this.addField(...)``` to set a 5-bit `lengthCounterLoad` field from bit 3
    **onWrite(value)**:
      **->** __keep old behavior__
      **->** determines the new length by accessing the `noteLengths` array with the ```javascript this.lengthCounterLoad``` index
        use 📄  ~/lib/apu/noteLengths.js~ to get the array
      **->** assigns the `counter` property of the channel's length counter to the new length
  responses: []
