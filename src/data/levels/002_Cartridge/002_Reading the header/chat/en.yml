---
main:
  run: |
    if (m.$end) $.goTo("exercise");
  messages:
  - hey
  - look at your 📁  ~/docs~ directory!
  responses:
  - what's there? [exercise]

exercise:
  run: |
    set((m) => m.$end = true);
  messages:
  - I've sent you some files
  - two diagrams of the hardware architecture
  - and a document describing the ~iNEEES~ format
  - you can inspect them with the ~open~ command
  - I want you to read it and tell me if you understand it
  responses:
  - 🤔  I think I understand [understand]
  - (*) what's a mapper? 🧠 [mapper]
  - (*) what's mirroring? 🚽 [mirroring]
  - (*) please define <PRG-ROM>, <CHR-ROM>, <PRG-RAM> and <CHR-RAM> 🐏 [memories]
  - (*) padding? 🧸 [padding]
  - (*) what the hell is a "nybble"? 🦴 [nybble]

mapper:
  messages:
  - it's kind of an "expansion chip" that every game has
  - they help the console read larger programs and graphics chunks
  - and they allow games to perform more complex operations like changing mirroring on the fly
  - more on that later! 🔜
  responses:
  - ...exercise

mirroring:
  messages:
  - it doesn't matter too much right now
  - mirroring affects what's shown past the right and bottom edges of the screen
  - depending on the mirroring type, the PPU will use different memory sections to draw backgrounds 🎨
  responses:
  - ...exercise

memories:
  messages:
  - "🤖  <PRG-ROM>: read-only memory that contains the program"
  - "👾  <CHR-ROM>: read-only memory that contains the graphics"
  - "👾  <CHR-RAM>: writable memory to store graphics in runtime"
  - "🔋  <PRG-RAM>: (optional) writable memory to store game progress"
  - each game uses either <CHR-ROM> or <CHR-RAM>
  - if it uses <CHR-RAM>, the ~iNEEES~ file will not contain its last <CHR-ROM> section
  responses:
  - ...exercise

padding:
  messages:
  - just zeroes, a part of the file which you can ignore
  responses:
  - ...exercise

nybble:
  messages:
  - a nybble is half a byte
  - so "lower nybble" means the first 4 bits and "upper nybble" means the last 4 bits
  responses:
  - ...exercise

understand:
  messages:
  - awesome 💪
  - |-
    📚  let's add a `header` property to the `Cartridge` class, with the following form:
    ```javascript {
      prgRomPages: 2, // (obtain this from byte 4)
      chrRomPages: 1, // (obtain this from byte 5)
      usesChrRam: false, // (true if chrRomPages === 0)
      has512BytePadding: false, // (obtain this from <Flags 6>)
      hasPrgRam: false, // (obtain this from <Flags 6>)
      mirroring: "VERTICAL", // (obtain this from <Flags 6>)
      mapperId: 4 // (obtain this from <Flags 6> and <Flags 7>)
    }```
  responses:
  - I need a bit of help 📐 [bits]

bits:
  messages:
  - if you don't know how to operate with bits, you can use my library 📖
  - it's in 📄  ~/lib/byte.js~, just import it as another module and use it
  - the methods you'd want to use are `getFlag`, `highNybbleOf`, `lowNybbleOf`, and `buildU8`
  responses:
  - how can I import the module? [import]

import:
  messages:
  - |-
    do it like this:
      ```javascript import byte from "/lib/byte";```
  - |-
    optionally, if you add it to your exported `index.js` object...
      ```javascript import Cartridge from "./Cartridge";
      import byte from "/lib/byte";

      export default { Cartridge, byte }```
  - you could test the library with the ~repl~ command
  - an interactive JS prompt! 🤯
  responses: []
