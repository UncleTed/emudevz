---
main:
  run: |
    if (level.hasStoredContent) $.goTo("exercise");
    else {
      set((m) => {
        m.chat.stopBlock = locales.get("not_now");
        m.$canRun = false;
        m.$canEdit = false;
      });
    }
  messages:
  - in case you didn't notice, all instructions can take one or zero arguments
  - and one compiled instruction can occupy 1, 2, or 3 bytes
  - <{compilation_full.png}>
  responses:
  - why are you telling me this? [why]

why:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - there are various ways to refer to these arguments
  - and they're called "addressing modes"
  - run the first instruction ⏩
  events:
  - step [implicit]

implicit:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4020]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - the instruction `INX` takes no arguments, so it's only 1 byte
  - ([PC] went from $4020 to $4021)
  - this is called the "Implicit" addressing mode
  - the argument is <implied> by the instruction itself
  - keep going ⏩
  events:
  - step [immediate]

immediate:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4021, 0x4022]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - "here, `LDA #$08` takes 1 byte as argument, so it's 2-byte long"
  - the "operation code" (<opcode>) and the 8
  - that's the "Immediate" addressing mode
  - where the argument is a <literal> byte
  - keep going ⏩
  events:
  - step [absolute]

absolute:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4023, 0x4024, 0x4025]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - "`LDA $C002` takes instead a memory address"
  - as it has a 2-byte argument, it compiles to 3 bytes
  - this is the "Absolute" addressing mode
  - where the argument is a <full> memory address
  - keep going ⏩
  events:
  - step [zeropage]

zeropage:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4026, 0x4027]);
  messages:
  - "`LDA $15` also takes a memory address"
  - but a short one, because it's only 1 byte
  - the full address would be $0015
  - that's the "Zero Page" addressing mode
  - where the argument is a <partial> memory address
  responses:
  - it looks like the same thing 😓 [samething]

samething:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - it's faster than the "Absolute" mode, as only one byte needs to be looked up
  - and takes up less space in the assembled code as well
  - but only the first page (the first 256 bytes) is accessible
  - keep going ⏩
  events:
  - step [relative]

relative:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4028, 0x4029]);
  messages:
  - branching instructions use the "Relative" addressing mode
  - these take a single byte, which is used as an offset from the following instruction
  - look at the compiled code of `BNE @label` in $4028
  - $D0 is the opcode of `BNE`, and the $02 from $4029 is the jump offset 🦘
  - "this means that [PC] will jump to $402A + 2: directly into $402C, where `@label` starts"
  - (it'll skip the bytes of the two `INY`s)
  responses:
  - interesting, so that's how branching works [whoa]

whoa:
  run: |
    {{Bottom}}.setSelectedCells([0x4036, 0x4037, 0x4038]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - last one is a bit tricky 😶
  - "\"Indirect\" addressing uses an absolute address to look up another address"
  - reading the first address gives the <least significant byte> (also called "low byte", ```raw $00```~XX~)
  - and reading the following byte (address + 1) gives the <most significant byte> (also called "high byte", ```raw $```~XX~```raw 00```)
  - that can be hard to wrap your head around, so let's run the example ⏩
  events:
  - step [step1]

step1:
  messages: []
  events:
  - step [step2]

step2:
  messages: []
  events:
  - step [step3]

step3:
  messages: []
  events:
  - step [step4]

step4:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - now $4080 contains $21, and $4081 contains $40
  - so, in this case, `JMP ($4080)` will unconditionally jump to $4021
  - <{JMP_indirect.png}>
  - creating an infinite loop ⏩
  events:
  - step [exercise]

exercise:
  run: |
    level.fillContentFromTemp();
    set((m) => {
      m.chat.stopBlock = null;
      m.$canRun = true;
      m.$canEdit = true;
      m.content.useTemp = false;
    });
    {{Bottom}}.setSelectedCells([]);
  messages:
  - there we go...
  - 📚  _-_as an exercise, modify the code by adding an `STY $1001` instruction at the end_--_
  - 📚  _-_then an `INX` instruction_--_
  - 📚  _-_and lastly, change lines 10 and 12, so the indirect `JMP` goes directly into the new `INX` _--_👀
  - 📚  _-_when you're done, run the `test` command_--_
  responses:
  - wait, what? [what]

what:
  messages:
  - after your change, instead of jumping backwards, it should skip the `STY $1001` and jump to our new last instruction
  - ⚠️  don't change the `JMP` itself, the idea is that the same `JMP ($4080)` jumps to another place
  - you'll need to look the address of the last `INX` inside the compiled code 😉
  responses: []
