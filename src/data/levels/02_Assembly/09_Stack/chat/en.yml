---
main:
  run: |
    set((m) => {
      m.chat.stopBlock = locales.get("not_now");
      m.$canRun = false;
      m.$canEdit = false;
    });
  messages:
  - the stack 🧱  is a <LIFO> structure ("Last In, First Out") which programs can use to store values
  - the current stack depth is measured by the "Stack Pointer" ([SP])
  - in a 6502 processor, it lives in memory between $0100 and $01FF 🐏
  - "[SP] is initially $FF, which points to the last stack byte ($01FF)"
  - when a byte is pushed onto the stack, [SP] becomes $FE (or memory address $01FE), and so on
  - here's an example of a stack with 2 values (in $01FF and $01FE), so [SP] points to $01FD
  - <{stack.png}>
  responses:
  - and how can I put values on it? [put]

put:
  messages:
  - "you use two instructions:"
  - "⬆️  `PHA` (\"PusH Accumulator\"), which adds [A] to the stack"
  - <{stack_PHA.png}>
  - "⬇️  `PLA` (\"PulL Accumulator\"), which removes the last byte from the stack, and loads it into [A]"
  - <{stack_PLA.png}>
  responses:
  - can you explain to me the example code? [example]

example:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - it creates two loops ➰
  - "`@save` puts odd numbers from $4080 to $4087"
  - and `@load` puts those numbers in reverse order from $4098 to $409F
  - the former <pushes> values onto the stack, the latter <pulls> values from the stack
  - now your debugger has a Stack section 👀
  - run the code and check it out for yourself ⏩
  responses:
  - nice, I get it now [exercise]
  - (*) why doesn't `PLA` remove the value from the stack? [remove]

remove:
  messages:
  - it "removes" it, just by incrementing [SP]
  - the value is kept in memory though 😅
  - there's no reason to remove it, as you'd only access the stack with the appropriate instructions
  responses:
  - ...example

exercise:
  run: |
    level.test.precode = "pretest.asm";
    level.fillContentFromTemp();
    set((m) => {
      m.chat.stopBlock = null;
      m.$canRun = true;
      m.$canEdit = true;
      m.content.useTemp = false;
    });
  messages:
  - now, an exercise
  - 📚  remove all the code
  - your stack will have 2 random preloaded values
  - 📚  you just need to pull and load them into 2 consecutive memory addresses
  - 📚  then, perform an indirect `JMP` 🦘
  - e.g. if your stack has -from top to bottom- $C4 and $3E, when your program finishes, [PC] should be $3EC4
  - 📚  run `test` when it's all done 😊
  responses: []
