---
main:
  run: |
    if (level.hasStoredContent) $.goTo("exercise");
    else {
      set((m) => {
        m.chat.stopBlock = locales.get("not_now");
        m.$canRun = false;
        m.$canEdit = false;
      });
    }
  messages:
  - hasta ahora, solo corrimos programas sin bifurcaciones
  - vamos a cambiar eso
  - el lenguaje ensamblador para 6502 tiene multiples instrucciones para bifurcar 🌲
  - todas ellas saltan cuando ciertas banderas están activadas o no
  responses:
  - (*) ¿"para 6502"? 🤔 [asm6502]
  - bueno y cómo salto [how]

asm6502:
  messages:
  - ese es el nombre del procesador de la NEEES, "6502"
  - cada lenguaje ensamblador está diseñado para una CPU específica
  - con su propio conjunto de instrucciones
  - así que, estamos escribiendo "lenguaje ensamblador para 6502" 🙂
  responses:
  - ...main

how:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - vamos a analizar `BNE`
  - ("Branch on Not Equal")
  - corre las primeras 5 instrucciones para ver qué hacen ⏩
  events:
  - step [step1]

step1:
  messages: []
  events:
  - step [step2]

step2:
  messages: []
  events:
  - step [step3]

step3:
  messages: []
  events:
  - step [step4]

step4:
  messages: []
  events:
  - step [step5]

step5:
  run: |
    set((m) => m.$canRun = false);
  messages:
  - esto es lo que pasó
  - "`CPX #3` 'ComPara' [X] con 3, y activa la Bandera Zero si son iguales"
  - "[X] tiene un 7, y eso no es igual a 3, así que Z = 0"
  - "`BNE @decrement` salta a esa etiqueta si la Bandera Zero no está activada"
  - ¡que no lo está! así que saltó 🦘
  - ([X] y 3 eran "Not Equal", por eso el nombre)
  responses:
  - ah, ya veo [oh]

oh:
  run: |
    set((m) => m.$canRun = true);
  messages:
  - ahora, corre el resto del código ⏩
  events:
  - end [exercise]

exercise:
  run: |
    level.fillContentFromTemp();
    set((m) => {
      m.chat.stopBlock = null;
      m.$canRun = true;
      m.$canEdit = true;
      m.content.useTemp = false;
    });
  messages:
  - el opuesto de `BNE` es `BEQ`, que salta cuando los números son iguales
  - vamos a practicar 👾
  - 📚  _-_borra el código actual_--_
  - _-_y construye un programa que lea el valor de $4080_--_
  - _-_si tiene un 7, escribe $EE en $40BF_--_
  - _-_si no, escribe $AA en $40BF_--_
  - _-_luego, ejecuta el comando `test`_--_
  responses:
  - momento, ¿cómo pruebo esto? 🧪 [testing]
  - necesito ayuda 😅 [help]

testing:
  messages:
  - configuré un generador de números aleatorios 🔢
  - cada vez que cambies/corras tu código, escribirá un 7 o un byte aleatorio en $4080
  - con 50% de probabilidades cada cosa
  - así que cuando sea 7, tu código debería escribir $EE
  - y cuando no, $AA tendría que ser escrito
  responses:
  - necesito ayuda 😅 [help]

help:
  messages:
  - 🔀  siempre querrás usar `BEQ` y `BNE` luego de una instrucción de comparación (como `CPX`)
  - "`CPX` asigna el flag Z=1 si [X] es igual al valor, y luego `BEQ`/`BNE` saltan dependiendo de si Z es 1 o 0"
  - <{CPX_BEQ.png}>
  - 🏷️  recuerda que la ejecución siempre es de arriba hacia abajo, ignorando etiquetas
  - por lo que probablemente en algún momento necesites parar el programa (para evitar que "siga de largo")
  - 🛑  para eso, puedes poner una etiqueta al final del código
  - y usar una instrucción de bifurcación para saltar a ella
  - o más fácil, usa la instrucción `BRK`, que interrumpe la ejecución 😉
  responses: []
