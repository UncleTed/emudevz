---
main:
  run: |
    if (m.$end) $.goTo("exercise");
  messages:
  - we preserve games in digital format with <game files> (also called ROMs) ðŸ‘¾
  - these contain code, graphics, and a header that identifies the hardware
  responses:
  - they're the famous *.neees files, right? [neeesfiles]

neeesfiles:
  messages:
  - right, the format is called ~iNEEES~, and you should start by reading its header
  - "the first 4 bytes of a game file always contain the following:"
  - $4E $45 $53 $1A
  - that's <the magic constant> âœ¨
  - you should look for these bytes to check whether a ROM is valid or not
  responses:
  - what do you want me to do? [exercise]

exercise:
  run: |
    set((m) => m.$end = true);
  messages:
  - ðŸ“š  _-_add a constructor to the `Cartridge` class receiving the ROM bytes_--_
  - ðŸ“š  _-_save them in a property called `bytes`_--_
  - ðŸ“š  _-_if the magic constant doesn't match $4E $45 $53 $1A, throw an error with the "Invalid ROM." message_--_
  responses:
  - how can I add a constructor? ðŸ˜³ [constructor]
  - I need help checking the bytes ðŸ¥º [help]
  - help me throw an error ðŸ¤” [errors]

constructor:
  messages:
  - |-
    after adding a constructor and saving the bytes, your code should look like this:
      ```javascript
      export default class Cartridge {
        constructor(bytes) {
          this.bytes = bytes;
          // check the bytes here!
        }
      }
      ```
  responses: []

help:
  messages:
  - you'll receive a `Uint8Array`, which works similar to regular arrays!
  - so ```javascript bytes[0]``` represents the first byte, ```javascript bytes[1]``` the second one, and so on
  - remember that you can express hexadecimal notation with the ~0x~ prefix, i.e. ~0x4e~
  responses: []

errors:
  messages:
  - "to throw errors, use:\n  ```javascript throw new Error(\"a message\");```"
  responses: []
