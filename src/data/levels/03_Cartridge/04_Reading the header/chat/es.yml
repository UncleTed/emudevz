---
main:
  run: |
    if (m.$end) $.goTo("exercise");
  messages:
  - ey
  - ¡mira tu directorio 📁  ~/docs~!
  responses:
  - ¿qué hay ahí? [exercise]

exercise:
  run: |
    set((m) => m.$end = true);
  messages:
  - te envié algo de documentación 🤓
  - revisa 📄  ~/docs/iNEEES.es.md~
  - es un documento que describe el formato iNEEES
  - puedes inspeccionarlo con el comando `open`, o <clickeando> en la ruta al archivo
  - quiero que lo veas y me digas si entiendes
  responses:
  - 🤔  creo que entiendo [understand]
  - (*) ¿qué es un mapper? 🗜️ [mapper]
  - (*) ¿qué es mirroring? 🚽 [mirroring]
  - (*) por favor, define PRG-ROM, CHR-ROM, PRG-RAM y CHR-RAM 🐏 [memories]
  - (*) ¿relleno? 🧸 [padding]
  - (*) ¿qué demonios es un "nybble"? 🦴 [nybble]

mapper:
  messages:
  - es como un "chip de expansión" que todo juego tiene
  - ayudan a la consola a leer programas y datos gráficos más grandes
  - y permiten que los juegos realicen operaciones más complejas como modificar el mirroring sobre la marcha
  - ¡más sobre eso luego! 🔜
  responses:
  - ...exercise

mirroring:
  messages:
  - el mirroring define qué se va a mostrar pasado el borde derecho e inferior de la pantalla
  - dependiendo del tipo de mirroring, la PPU usará diferentes secciones de memoria para dibujar fondos 🎨
  - no importa demasiado por ahora
  responses:
  - ...exercise

memories:
  messages:
  - ok, intentaré...
  - "🤖  PRG-ROM: memoria de solo lectura que contiene el programa"
  - "👾  CHR-ROM: memoria de solo lectura que contiene los gráficos"
  - "👾  CHR-RAM: memoria escribible para poner gráficos en tiempo de ejecución"
  - "🔋  PRG-RAM: (opcional) memoria escribible para almacenar el progreso del juego"
  - cada juego usa CHR-ROM o CHR-RAM
  - si usa CHR-RAM, el archivo iNEEES no contendrá su última sección de CHR-ROM
  responses:
  - ...exercise

padding:
  messages:
  - solo ceros, una parte del archivo que puedes ignorar
  responses:
  - ...exercise

nybble:
  messages:
  - un nybble es medio byte
  - por lo que "nybble inferior" significa los primeros 4 bits (```raw 0000```~1011~)
  - y "nybble superior" significa los últimos 4 bits (~1011~```raw 0000```)
  responses:
  - ...exercise

understand:
  messages:
  - excelente 💪
  - los primeros 16 bytes del archivo representan la 🗣️  cabecera
  - |-
    📚  agreguemos una propiedad `header` a la clase 💾  `Cartridge`, con la siguiente forma:
    ```javascript {
      prgRomPages: 2, // (obtener esto del byte 4)
      chrRomPages: 1, // (obtener esto del byte 5)
      usesChrRam: false, // (true si chrRomPages === 0)
      has512BytePadding: false, // (obtener esto de <Flags 6>)
      hasPrgRam: false, // (obtener esto de <Flags 6>)
      mirroringId: "VERTICAL", // (obtener esto de <Flags 6>)
      mapperId: 4 // (obtener esto de <Flags 6> y <Flags 7>)
    }```
  responses:
  - necesito un poco de ayuda 📐 [bits]

bits:
  messages:
  - si no sabes cómo operar con bits, puedes usar mi biblioteca 📖
  - está en 📄  ~/lib/byte.js~, solo impórtala como otro módulo más y úsala
  - los métodos que querrás usar son `getFlag(...)`, `highNybbleOf(...)`, `lowNybbleOf(...)` y `buildU8(...)`
  responses:
  - ¿cómo puedo usar el módulo? [import]

import:
  messages:
  - |-
    solo impórtalo así:
      ```javascript import byte from "/lib/byte";```
  - 💡 puedes probar la biblioteca con el comando `repl`
  - ¡una consola JS interactiva! 🤯
  - |-
    intenta ejecutar estas líneas de código:
    ```javascript
    // (0x implica <hexadecimal> y 0b implica <binario>)
    byte.getFlag(0b00000100, 2) // el bit 2 es 1 => true
    byte.getFlag(0b00000100, 4) // el bit 4 es 0 => false
    byte.highNybbleOf(0b00110100) // el high nybble es 0b0011 => 3
    byte.lowNybbleOf(0b00110100) // el low nybble es 0b0100 => 4
    byte.buildU8(0b0011, 0b0100) // 0b00110100 => 52```
  responses: []
