---
main:
  run: |
    if (m.$end) $.goTo("exercise");
  messages:
  - hey
  - look at your 📁  ~/docs~ directory!
  responses:
  - what's there? [exercise]

exercise:
  run: |
    set((m) => m.$end = true);
  messages:
  - I've sent you some documentation 🤓
  - check out 📄  ~/docs/iNEEES.en.md~
  - it's a document describing the iNEEES format
  - you can inspect it with the `open` command, or by <clicking> on the file path
  - I want you to read it and tell me if you understand
  responses:
  - 🤔  I think I understand [understand]
  - (*) what's a mapper? 🗜️ [mapper]
  - (*) what's mirroring? 🚽 [mirroring]
  - (*) please define PRG-ROM, CHR-ROM, PRG-RAM and CHR-RAM 🐏 [memories]
  - (*) padding? 🧸 [padding]
  - (*) what the hell is a "nybble"? 🦴 [nybble]

mapper:
  messages:
  - it's kind of an "expansion chip" that every game has
  - they help the console read larger programs and graphics chunks
  - and they allow games to perform more complex operations like changing mirroring on the fly
  - more on that later! 🔜
  responses:
  - ...exercise

mirroring:
  messages:
  - mirroring affects what's shown past the right and bottom edges of the screen
  - depending on the mirroring type, the PPU will use different memory sections to draw backgrounds 🎨
  - it doesn't matter too much right now
  responses:
  - ...exercise

memories:
  messages:
  - ok, let's try...
  - "🤖  PRG-ROM: read-only memory that contains the program"
  - "👾  CHR-ROM: read-only memory that contains the graphics"
  - "👾  CHR-RAM: writable memory to store graphics at runtime"
  - "🔋  PRG-RAM: (optional) writable memory to store game progress"
  - each game uses either CHR-ROM or CHR-RAM
  - if it uses CHR-RAM, the iNEEES file will not contain its last CHR-ROM section
  responses:
  - ...exercise

padding:
  messages:
  - just zeroes, a part of the file which you can ignore
  responses:
  - ...exercise

nybble:
  messages:
  - a nybble is half a byte
  - so "lower nybble" means the first 4 bits (```raw 0000```~1011~)
  - and "upper nybble" means the last 4 bits (~1011~```raw 0000```)
  responses:
  - ...exercise

understand:
  messages:
  - awesome 💪
  - the first 16 bytes of the file represent the 🗣️  header
  - |-
    📚  let's add a `header` property to the 💾  `Cartridge` class, with the following form:
    ```javascript {
      prgRomPages: 2, // (obtain this from byte 4)
      chrRomPages: 1, // (obtain this from byte 5)
      usesChrRam: false, // (true if chrRomPages === 0)
      has512BytePadding: false, // (obtain this from <Flags 6>)
      hasPrgRam: false, // (obtain this from <Flags 6>)
      mirroringId: "VERTICAL", // (obtain this from <Flags 6>)
      mapperId: 4 // (obtain this from <Flags 6> and <Flags 7>)
    }```
  responses:
  - I need a bit of help 📐 [bits]

bits:
  messages:
  - if you don't know how to operate with bits, you can use my library 📖
  - it's in 📄  ~/lib/byte.js~, just import it as another module and use it
  - the methods you'd want to use are `getFlag(...)`, `highNybbleOf(...)`, `lowNybbleOf(...)`, and `buildU8(...)`
  responses:
  - how can I use the module? [import]

import:
  messages:
  - |-
    just import it like this:
      ```javascript import byte from "/lib/byte";```
  - 💡 you can test the library by using the `repl` command
  - an interactive JS prompt! 🤯
  - |-
    try running these lines of code:
    ```javascript
    // (0x means <hexadecimal> and 0b means <binary>)
    byte.getFlag(0b00000100, 2) // bit 2 is 1 => true
    byte.getFlag(0b00000100, 4) // bit 4 is 0 => false
    byte.highNybbleOf(0b00110100) // high nybble is 0b0011 => 3
    byte.lowNybbleOf(0b00110100) // low nybble is 0b0100 => 4
    byte.buildU8(0b0011, 0b0100) // 0b00110100 => 52```
  responses: []
