---
main:
  run: |
    set((m) => {
      m.chat.winOnEnd = true;
      m.chat.stopBlock = locales.get("not_now");
      m.$canRun = false;
    });
  messages:
  - déjame presentarte al editor de código
  - bueno, aún no es <editor> 😅
  - solo un visor
  - tiene un ejemplo de un programa básico de NEEES
  responses:
  - (*) el visor no me asusta, lo que sí lo hace son los números raros de abajo [debugger]
  - ¿qué lenguaje es éste? 😮 [language]

debugger:
  messages:
  - ¿el depurador de CPU?
  - nah, no te preocupes
  - ¡voy a explicar todo!
  responses:
  - ...main

language:
  messages:
  - ¡es lenguaje ensamblador!
  - el nivel más bajo de abstracción de las computadoras 💻
  - se traduce directo a los bytes que son ejecutados por la CPU
  responses:
  - entonces, después de compilar, ¿se va a convertir en un conjunto raro de bytes? [machinecode]

machinecode:
  messages:
  - correcto
  - de hecho, estás viendo el código compilado ahora mismo
  - fíjate en el Visor de Memoria en la parte de abajo de la pantalla
  - el código empieza desde la dirección de memoria $4020
  - si posas el cursor de tu mouse sobre una de estas direcciones, mostrará dónde empieza cada instrucción
  responses:
  - (*) ¿qué es una dirección de memoria? [address]
  - ¿qué son los otros números? 👀 [otherthings]

address:
  messages:
  - un número de 2 bytes que representa una ubicación dentro de la memoria 🐏
  - puede ir de 0 ($0000) a 65535 ($FFFF)
  responses:
  - pero dijiste que la NEEES solo tenía 2KiB (2048 bytes) de memoria 😕 [butyousaid]
  - ...machinecode

butyousaid:
  messages:
  - eso es cierto
  - pero la CPU puede <ver> hasta 64KiB
  - así que los primeros dos kilobytes son RAM de verdad
  - y el resto se usa para interactuar con el hardware 💻
  - eso no importa mucho en este capítulo
  - estamos simulando una RAM de 64KiB por simplicidad
  responses:
  - ...machinecode

otherthings:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - vamos a ejecutar el código y descubrirlo
  - agregué un botón ⏩  a la sección de código
  - "¿podrás clickearlo? 🙏"
  events:
  - step [lda]

lda:
  run: |
    set((m) => m.$canRun = false);
  messages:
  - ¡genial!
  - si prestaste atención, seguramente viste que [A] cambió de $00 a $01
  - y [PC] cambió de $4020 a $4022 🤯
  - estos son registros de CPU, ubicaciones rápidamente accesibles
  - cada registro puede almacenar un solo byte (8 bits) de datos
  - con la excepción de [PC] ("Program Counter") que ocupa 2 bytes
  responses:
  - ¿cuál es el propósito de cada registro? [registers]

registers:
  messages:
  - bueno, [A] significa "Accumulator" y su uso depende del programa
  - "[PC] siempre apunta a la próxima instrucción a ejecutar"
  responses:
  - "entonces, con `LDA #$01` simplemente le dijiste al procesador que almacenara el número $01 en [A]? 😲 [ldaexplanation]"
  - "(*) me dan curiosidad los otros: [X], [Y] y [SP] [theothers]"

theothers:
  run: |
    set((m) => m.$others = true);
  messages:
  - más adelante voy a hablar de eso, pero básicamente
  - "[X] e [Y] pueden almacenar cualquier valor, al igual que [A]"
  - tienen un significado especial cuando trabajas con direcciones de memoria 🐏
  - y [SP] es el "Stack Pointer"
  responses:
  - <!m.$hasEnded> ...registers
  - <m.$hasEnded> ...finish

ldaexplanation:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - exactamente, LDA significa "LoaD Accumulator"
  - 💸  todos los números con el prefijo $ están en notación hexadecimal
  - "🔢  cualquier cosa con el prefijo # es un valor numérico literal"
  - 🐏  cualquier otro número refiere a una ubicación de memoria
  - ¡ahora ejecuta la siguiente instrucción! ⏩
  events:
  - step [sta]

sta:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - STA significa "STore Accumulator"
  - y como puedes ver, escribe el contenido de [A] en una ubicación de memoria
  - en este ejemplo, en la dirección $4070
  - así que ahora la celda $4070 del Visor de Memoria tiene un $01
  - intenta ejecutar las instrucciones restantes ⏩
  events:
  - end [finish]

finish:
  run: |
    set((m) => m.$hasEnded = true);
    {{Bottom}}.setDelay(500);
  messages:
  - increíble, ahora conoces el funcionamiento básico de una CPU
  - clickea el butón ⏮  y ejecuta la simulación las veces que necesites
  - cuando quieras, podemos ir al siguiente nivel
  responses:
  - 💪  creo que ya entendí todo [end]
  - <!m.$others> (*) ¿y qué onda con [X], [Y], and [SP]? [theothers]
  - (*) I don't like clicking buttons [clicking]

clicking:
  messages:
  - hmm...
  - you can navigate to the code section with `Alt+Up`
  - then hit `Alt+Enter`
  - and go back with `Alt+Left`
  responses:
  - ...finish
