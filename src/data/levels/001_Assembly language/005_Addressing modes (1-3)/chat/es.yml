---
main:
  run: |
    if (level.hasStoredContent) $.goTo("exercise");
    else {
      set((m) => {
        m.chat.stopBlock = locales.get("not_now");
        m.$canRun = false;
        m.$canEdit = false;
      });
    }
  messages:
  - por si no te diste cuenta, todas las instrucciones toman uno o cero argumentos
  - y una instrucci√≥n compilada puede ocupar 1, 2 o 3 bytes
  responses:
  - ¬øpor qu√© me est√°s contando esto? [why]

why:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - hay varias formas de referirse estos argumentos
  - y se llaman "modos de direccionamiento"
  - corre la primer instrucci√≥n ‚è©
  events:
  - step [implicit]

implicit:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4020]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - la instrucci√≥n `INX` no toma argumentos, por lo que es de solo 1 byte
  - ([PC] pas√≥ de $4020 a $4021)
  - esto se llama modo de direccionamiento "Implicit"
  - el argumento est√° <impl√≠cito> en la instrucci√≥n misma
  - sigue ‚è©
  events:
  - step [immediate]

immediate:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4021, 0x4022]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - "aqu√≠, `LDA #$08` toma 1 byte como argumento, por lo que ocupa 2 bytes"
  - el "c√≥digo de operaci√≥n" (<opcode>) y el ocho
  - esto es el modo de direccionamiento "Immediate"
  - donde el argumento es un byte <literal>
  - sigue ‚è©
  events:
  - step [absolute]

absolute:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4023, 0x4024, 0x4025]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - "`LDA $C002` en cambio toma una direcci√≥n de memoria"
  - como tiene un argumento de 2 bytes, se compila a 3 bytes
  - este es el modo de direccionamiento "Absolute"
  - donde el argumento es una direcci√≥n de memoria <completa>
  - sigue ‚è©
  events:
  - step [zeropage]

zeropage:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4026, 0x4027]);
  messages:
  - "`LDA $15` tambi√©n toma una direcci√≥n de memoria"
  - pero una corta, porque solo es 1 byte
  - la direcci√≥n completa ser√≠a $0015
  - eso es el modo de direccionamiento "Zero Page"
  - donde el argumento es una direcci√≥n de memoria <parcial>
  responses:
  - parece la misma cosa üòì [samething]

samething:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - es m√°s r√°pido que el modo "Absolute", ya que solo se necesita buscar un byte
  - y adem√°s ocupa menos espacio en el c√≥digo ensamblado
  - pero solo la primera p√°gina (los primeros 256 bytes) es accesible
  - sigue ‚è©
  events:
  - step [relative]

relative:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4028, 0x4029]);
  messages:
  - las instrucciones de bifurcaci√≥n usan el modo de direccionamiento "Relative"
  - √©stas toman un solo byte, que es usado como un desplazamiento desde la siguiente instrucci√≥n
  - mira el c√≥digo compilado de `BNE @label` en $4028
  - $D0 es el opcode de `BNE`, y el $02 de $4029 es el desplazamiento del salto ü¶ò
  - "esto significa que [PC] saltar√° a $402A + 2: directo hacia $402C, donde comienza @label"
  - (omitir√° los bytes de los dos `INY`s)
  responses:
  - interesante, conque as√≠ funcionan las bifurcaciones [whoa]

whoa:
  run: |
    {{Bottom}}.setSelectedCells([0x4036, 0x4037, 0x4038]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - la √∫ltima es un poco complicada üò∂
  - "el modo de direccionamiento \"Indirect\" lee una direcci√≥n absoluta (digamos <J>) para construir otra direcci√≥n absoluta (digamos <K>)"
  - el contenido de <J> da el byte menos significativo de <K>
  - y el siguiente byte (el contenido de <J>+1) da el byte m√°s significativo de <K>
  - corre el ejemplo ‚è©
  events:
  - step [step1]

step1:
  messages: []
  events:
  - step [step2]

step2:
  messages: []
  events:
  - step [step3]

step3:
  messages: []
  events:
  - step [step4]

step4:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - ahora $4080 contiene $21, y $4081 contiene $40
  - por lo que en este caso, `JMP ($4080)` saltar√° incondicionalmente a $4021"
  - creando un bucle infinito ‚è©
  events:
  - step [exercise]

exercise:
  run: |
    level.fillContentFromTemp();
    set((m) => {
      m.chat.stopBlock = null;
      m.$canRun = true;
      m.$canEdit = true;
      m.content.useTemp = false;
    });
    {{Bottom}}.setSelectedCells([]);
  messages:
  - ah√≠ est√°...
  - como ejercicio, modifica el c√≥digo agregando una instrucci√≥n `STY $1001` al final
  - luego una instrucci√≥n `INX`
  - y por √∫ltimo, cambia las l√≠neas 10 y 12 para que el `JMP` indirecto vaya directamente a la nueva `INX` üëÄ
  - cuando termines, ejecuta el comando `test`
  responses:
  - momento, ¬øqu√©? [what]

what:
  messages:
  - luego de tu cambio, en vez de saltar hacia atr√°s, deber√≠a omitir `STY $1001` y saltar a nuestra nueva √∫ltima instrucci√≥n
  - ‚ö†Ô∏è  no cambies el `JMP` en s√≠ mismo, la idea es que el mismo `JMP ($4080)` salte a otro lugar
  - necesitar√°s mirar la direcci√≥n del √∫ltimo `INX` dentro del c√≥digo compilado üòâ
  responses: []
