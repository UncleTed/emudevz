---
main:
  messages:
  - ok, let's draw tiles
  - read 📄  ~/docs/ppu/tile_rendering.en.md~
  - it should explain how tiles are encoded in memory
  - we'll create a class to help us retrieve tile colors
  - as the PPU renders by 🌠  scanlines, it will receive a parameter (`y`) that represents the row index it should draw
  - |-
    📚  create a 🕊️  `Tile` class with the following:
    **constructor(ppu, patternTableId, tileId, y)**:
      **->** calculates the start address of the pattern table:
        $0000 or $1000 depending on `patternTableId` (~0~ or ~1~)
        (let's call this `tableAddress`)
      **->** calculates the start address of the tile's 💜  low plane:
        ```javascript tableAddress + tileId * 16```
        (let's call this `lowPlaneAddress`)
      **->** calculates the start address of the tile's 💚  high plane:
        ```javascript lowPlaneAddress + 8```
        (let's call this `highPlaneAddress`)
      **->** reads the correct row of each bitplane:
        ```javascript this._lowRow``` = read PPU address ```javascript lowPlaneAddress + y``` from ```javascript ppu.memory```
        ```javascript this._highRow``` = read PPU address ```javascript highPlaneAddress + y``` from ```javascript ppu.memory```
    **getColorIndex(x)**:
      **->** determines the bit position that corresponds to `x` (a number between 0 and 7)
        keep in mind that ~x=0~ is the leftmost pixel, and that would be ~bit 7~
      **->** grabs that bit from ```javascript this._lowRow``` and ```javascript this._highRow``` using `javascript byte.getBit(...)`
      **->** returns the resulting color index, combining the two bits with `byte.buildU2(...)`
  responses:
  - how will we test this? 🧐 [test]

test:
  messages:
  - good question! 😁
  - |+
    📚  in your 🖥️  `PPU`, import the 🕊️  `Tile` class and replace the test code (before the `onFrame` call) with:

      ```javascript
      // <test>
      const testPalette = [0xffffffff, 0xff999999, 0xff424242, 0xff000000];
      const scale = 2;
      
      for (let tileId = 0; tileId < 240; tileId++) {
        const scaledSize = 8 * scale;
        const tilesPerRow = 256 / scaledSize;
        const startX = (tileId % tilesPerRow) * scaledSize;
        const startY = Math.floor(tileId / tilesPerRow) * scaledSize;
        
        for (let y = 0; y < 8; y++) {
          const tile = new Tile(this, 0, tileId, y);
          
          for (let x = 0; x < 8; x++) {
            const color = testPalette[tile.getColorIndex(x)];
            
            for (let scaledY = 0; scaledY < scale; scaledY++) {
              for (let scaledX = 0; scaledX < scale; scaledX++) {
                this.plot(
                  startX + x * scale + scaledX, 
                  startY + y * scale + scaledY, 
                  color
                );
              }
            }
          }
        }
      }
      // </test>```
  - this will draw the first 240 tiles from 👾  CHR-ROM
  - with a ~2x~ scale (~16x16~ tiles instead of ~8x8~)
  - ⚠️  it will <only> work on games that use 👾  CHR-ROM ⚠️
  responses:
  - what happens with games that use 👾  CHR-RAM? [chrram]

chrram:
  messages:
  - those games load tiles dynamically through game code 🤖
  - and currently, the 🧠  CPU has <no way> of writing our 🖥️  PPU memory
  - so in those cases, you will only see a blank screen
  responses: []
