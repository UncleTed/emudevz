---
main:
  messages:
  - ok, vamos a dibujar tiles
  - lee 📄  ~/docs/ppu/tile_rendering.es.md~
  - debería explicar cómo los tiles están codificados en memoria
  - vamos a crear una clase para ayudarnos a recuperar los colores de los tiles
  - dado que la PPU renderiza por 🌠  scanlines, recibirá un parámetro (`y`) que representa el índice de la fila que debe dibujar
  - |-
    📚  _-_crea una clase `Tile` con lo siguiente:_--_
    *_-_*constructor(ppu, patternTableId, tileId, y)**:_--_
      *_-_*->** calcula la dirección inicial de la pattern table:_--_
        _-_$0000 o $1000 dependiendo de ~patternTableId~ (~0~ o ~1~)_--_
        _-_(llamemos a esto ~tableAddress~)_--_
      *_-_*->** calcula la dirección inicial del _--_💜 _-_ low plane:_--_
        _-_~tableAddress + tileId * 16~_--_
        _-_(llamemos a esto ~lowPlaneAddress~)_--_
      *_-_*->** calcula la dirección inicial del _--_💚 _-_ high plane:_--_
        _-_~lowPlaneAddress + 8~_--_
        _-_(llamemos a esto ~highPlaneAddress~)_--_
      *_-_*->** lee la fila correcta de cada bitplane:_--_
        _-_~this._lowRow~ = leer dirección PPU ~lowPlaneAddress + y~_--_
        _-_~this._highRow~ = leer dirección PPU ~highPlaneAddress + y~_--_
    *_-_*getColorIndex(x)**:_--_
      *_-_*->** determina la posición del bit que corresponde a ~x~ (un número entre 0 y 7)_--_
        _-_ten en cuenta que ~x=0~ es el píxel más a la izquierda, y eso sería ~bit 7~_--_
      *_-_*->** toma ese bit de ~this._lowRow~ y ~this._highRow~ usando `byte.getBit(...)`_--_
      *_-_*->** devuelve el índice de color resultante, combinando los dos bits con `byte.buildU2(...)`_--_
  responses:
  - ¿cómo lo probaremos? 🧐 [test]

test:
  messages:
  - ¡buena pregunta! 😁
  - |+
    _-_en tu `PPU`, reemplaza el código de prueba (antes de la llamada `onFrame`) con:

      ```javascript
      // <test>
      const testPalette = [0xffffffff, 0xff999999, 0xff424242, 0xff000000];
      const scale = 2;
      
      for (let tileId = 0; tileId < 240; tileId++) {
        const scaledSize = 8 * scale;
        const tilesPerRow = 256 / scaledSize;
        const startX = (tileId % tilesPerRow) * scaledSize;
        const startY = Math.floor(tileId / tilesPerRow) * scaledSize;
        
        for (let y = 0; y < 8; y++) {
          const tile = new Tile(this, 0, tileId, y);
          
          for (let x = 0; x < 8; x++) {
            const color = testPalette[tile.getColorIndex(x)];
            
            for (let scaledY = 0; scaledY < scale; scaledY++) {
              for (let scaledX = 0; scaledX < scale; scaledX++) {
                this.plot(
                  startX + x * scale + scaledX, 
                  startY + y * scale + scaledY, 
                  color
                );
              }
            }
          }
        }
      }
      // </test>```_--_
  - esto dibujará los primeros 240 tiles de 👾  <CHR-ROM>
  - con una escala de ~2x~ (tiles de ~16x16~ en lugar de ~8x8~)
  - ⚠️  funcionará <solo> en juegos que utilicen 👾  <CHR-ROM> ⚠️
  responses:
  - ¿qué pasa con los juegos que usan 👾  <CHR-RAM>? [chrram]

chrram:
  messages:
  - esos juegos cargan tiles dinámicamente a través del código del juego 🤖
  - y actualmente, la 🧠  CPU no tiene <ninguna forma> de escribir en nuestra 🖥️  memoria PPU
  - por lo que en esos casos, solo verás una pantalla en blanco
  responses: []
