---
main:
  messages:
  - ok, vamos a dibujar tiles
  - lee 📄  ~/docs/ppu/tile_rendering.es.md~
  - debería explicar cómo los tiles están codificados en memoria
  - vamos a crear una clase para ayudarnos a recuperar los colores de los tiles
  - dado que la PPU renderiza por 🌠  scanlines, recibirá un parámetro (`y`) que representa el índice de la fila que debe dibujar
  - |-
    📚  crea una clase 🕊️  `Tile` con lo siguiente:
    **constructor(ppu, patternTableId, tileId, y)**:
      **->** calcula la dirección inicial de la pattern table:
        $0000 o $1000 dependiendo de `patternTableId` (~0~ o ~1~)
        (llamemos a esto `tableAddress`)
      **->** calcula la dirección inicial del 💜  low plane:
        ```javascript tableAddress + tileId * 16```
        (llamemos a esto `lowPlaneAddress`)
      **->** calcula la dirección inicial del 💚  high plane:
        ```javascript lowPlaneAddress + 8```
        (llamemos a esto `highPlaneAddress`)
      **->** lee la fila correcta de cada bitplane:
        ```javascript this._lowRow``` = leer dirección PPU ```javascript lowPlaneAddress + y```
        ```javascript this._highRow``` = leer dirección PPU ```javascript highPlaneAddress + y```
    **getColorIndex(x)**:
      **->** determina la posición del bit que corresponde a `x` (un número entre 0 y 7)
        ten en cuenta que ~x=0~ es el píxel más a la izquierda, y eso sería ~bit 7~
      **->** toma ese bit de ```javascript this._lowRow``` y ```javascript this._highRow``` usando `byte.getBit(...)`
      **->** devuelve el índice de color resultante, combinando los dos bits con `byte.buildU2(...)`
  responses:
  - ¿cómo lo probaremos? 🧐 [test]

test:
  messages:
  - ¡buena pregunta! 😁
  - |+
    📚  en tu 🖥️  `PPU`, importa la clase 🕊️  `Tile` y reemplaza el código de prueba (antes de la llamada `onFrame`) con:

      ```javascript
      // <test>
      const testPalette = [0xffffffff, 0xff999999, 0xff424242, 0xff000000];
      const scale = 2;
      
      for (let tileId = 0; tileId < 240; tileId++) {
        const scaledSize = 8 * scale;
        const tilesPerRow = 256 / scaledSize;
        const startX = (tileId % tilesPerRow) * scaledSize;
        const startY = Math.floor(tileId / tilesPerRow) * scaledSize;
        
        for (let y = 0; y < 8; y++) {
          const tile = new Tile(this, 0, tileId, y);
          
          for (let x = 0; x < 8; x++) {
            const color = testPalette[tile.getColorIndex(x)];
            
            for (let scaledY = 0; scaledY < scale; scaledY++) {
              for (let scaledX = 0; scaledX < scale; scaledX++) {
                this.plot(
                  startX + x * scale + scaledX, 
                  startY + y * scale + scaledY, 
                  color
                );
              }
            }
          }
        }
      }
      // </test>```
  - esto dibujará los primeros 240 tiles de 👾  CHR-ROM
  - con una escala de ~2x~ (tiles de ~16x16~ en lugar de ~8x8~)
  - ⚠️  funcionará <solo> en juegos que utilicen 👾  CHR-ROM ⚠️
  responses:
  - ¿qué pasa con los juegos que usan 👾  CHR-RAM? [chrram]

chrram:
  messages:
  - esos juegos cargan tiles dinámicamente a través del código del juego 🤖
  - y actualmente, la 🧠  CPU no tiene <ninguna forma> de escribir en nuestra 🖥️  memoria PPU
  - por lo que en esos casos, solo verás una pantalla en blanco
  responses: []
