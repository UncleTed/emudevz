main:
  messages:
  - games also define, at runtime, how the sprites should look 🛸
  - they do so by writing a table called OAM ("Object Attribute Memory")
  - this table lives in an <internal> memory region called 🐏  OAM RAM
  responses:
  - how can a game write to 🐏  OAM RAM? [how]

how:
  messages:
  - "there are two ways:"
  - "1) using the registers 🏠  OAMAddr and 📝  OAMData"
  - "2) using ⚡  OAMDMA"
  responses:
  - (*) tell me about 🏠  OAMAddr and 📝  OAMData [addrdata]
  - (*) tell me about ⚡  OAMDMA [dma]
  - let's implement that bridge [exercise]

addrdata:
  messages:
  - there's not much to say about them
  - it's the same as 📍  PPUAddr and 📦  PPUData
  - but they access 🐏  OAM RAM instead of PPU memory
  responses:
  - ...how

dma:
  messages:
  - DMA ("Direct Memory Access") is a hardware mechanism to copy bytes from one memory region to another one really fast
  - in the NEEES, this is provided by the ⚡  OAMDMA register, which let games fill 🐏  OAM RAM by copying bytes from CPU memory
  - writing ```raw $```~XX~ to that register will copy 256 bytes from CPU addresses ```raw $```~XX~```raw 00```-```raw $```~XX~```raw FF``` to the internal OAM RAM
  - this operation will take around 513 CPU cycles, during which the CPU is suspended
  responses:
  - ...how

exercise:
  messages:
  - 📚  like you did with `PPUMemory::vram`, add a property called `oamRam` in 🐏  `PPUMemory`
  - the array should store 256 bytes
  - this time, you don't have to map it, OAM is very <internal>
  - |-
    📚  implement these methods in 📝  `OAMData`:
    **onRead()**:
      **->** saves the current OAM address:
        ```javascript const oamAddress = this.ppu.registers.oamAddr.value;```
        (the `value` field is defined in `InMemoryRegister` and represents the current value)
      **->** returns the corresponding byte from OAM RAM, using `oamAddress`
    **onWrite(value)**:
      **->** saves the current OAM address (`oamAddress`)
      **->** writes `value` to the corresponding byte from OAM RAM, using `oamAddress`
      **->** increments the OAM address:
        ```javascript this.ppu.registers.oamAddr.setValue(oamAddress + 1);```
  - |-
    📚  implement this method in ⚡  `OAMDMA`:
    **onWrite(value)**:
      **->** ```javascript for (i = 0; i < 256; i++)```:
        **->** builds the address (high byte: `value`, low byte: `i`)
        **->** reads the address from CPU memory (```javascript this.ppu.cpu``` retrieves the 🧠  `CPU`)
        **->** assigns the obtained byte to ```javascript oamRam[i]```
      **->** adds 513 to ```javascript this.ppu.cpu.extraCycles```
  responses: []

corollary:
  messages:
  - when launching a game, you'll now able to visualize the OAM and its sprites in the 🐞  <debugger window>
  responses:
  - ▶️  continue [end]
