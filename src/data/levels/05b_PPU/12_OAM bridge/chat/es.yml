main:
  messages:
  - los juegos también definen, en tiempo de ejecución, cómo deben lucir los sprites 🛸
  - lo hacen escribiendo una tabla llamada OAM ("Object Attribute Memory")
  - esta tabla se encuentra en una región de memoria <interna> llamada 🐏  OAM RAM
  responses:
  - ¿cómo puede un juego escribir en 🐏  OAM RAM? [how]

how:
  messages:
  - "hay dos maneras:"
  - "1) usando los registros 🏠  OAMAddr y 📝  OAMData"
  - "2) usando ⚡  OAMDMA"
  responses:
  - cuéntame sobre 🏠  OAMAddr y 📝  OAMData [addrdata]
  - cuéntame sobre ⚡  OAMDMA [dma]
  - implementemos ese puente [implement]

addrdata:
  messages:
  - no hay mucho que decir sobre ellos
  - es lo mismo que 📍  PPUAddr y 📦  PPUData
  - pero acceden a 🐏  OAM RAM en lugar de la memoria PPU
  responses:
  - ...how

dma:
  messages:
  - DMA ("Direct Memory Access") es un mecanismo de hardware para copiar bytes de una región de memoria a otra muy rápidamente
  - en el NEEES, esto se proporciona mediante el registro ⚡  OAMDMA, que permite a los juegos llenar 🐏  OAM RAM copiando bytes de la memoria de la CPU
  - escribir ```raw $```~XX~ en ese registro copiará 256 bytes de las direcciones CPU ```raw $```~XX~```raw 00```-```raw $```~XX~```raw FF``` a la OAM RAM interna
  - esta operación tomará alrededor de 513 ciclos de CPU, durante los cuales la CPU está suspendida
  responses:
  - ...how

implement:
  messages:
  - 📚  como hiciste con `PPUMemory::vram`, agrega una propiedad llamada `oamRam` en `PPUMemory`
  - el array debe almacenar 256 bytes
  - esta vez, no tienes que mapearla, la OAM es muy <interna>
  - |-
    📚  implementa estos métodos en `OAMData`:
    **onRead()**:
      **->** guarda la dirección OAM actual:
        ```javascript const oamAddress = this.ppu.registers.oamAddr.value;```
        (el campo `value` está definido en `InMemoryRegister` y representa el valor actual)
      **->** devuelve el byte correspondiente de OAM RAM, usando `oamAddress`
    **onWrite(value)**:
      **->** guarda la dirección OAM actual (`oamAddress`)
      **->** escribe `value` en el byte correspondiente de OAM RAM, usando `oamAddress`
      **->** incrementa la dirección OAM:
        ```javascript this.ppu.registers.oamAddr.setValue(oamAddress + 1);```
  - |-
    📚  implementa este método en `OAMDMA`:
    **onWrite(value)**:
      **->** ```javascript for (i = 0; i < 256; i++)```:
        **->** construye la dirección (high byte: `value`, low byte: `i`)
        **->** lee la dirección de la memoria de la CPU (```javascript this.ppu.cpu``` devuelve la `CPU`)
        **->** asigna el byte obtenido a ```javascript oamRam[i]```
      **->** suma 513 a ```javascript this.ppu.cpu.extraCycles```
  responses: []
