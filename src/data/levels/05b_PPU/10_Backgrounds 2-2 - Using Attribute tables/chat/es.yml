---
main:
  messages:
  - para permitir colores, primero necesitamos permitir que los juegos escriban información de color
  - en otras palabras, necesitamos mapear 🐏  Palette RAM en nuestra memoria PPU
  - luego, agregaremos métodos para leer paletas de colores
  - y finalmente, haremos que `BackgroundRenderer` use paletas para renderizar
  - 📚  como hiciste con `PPUMemory::vram`, agrega una propiedad llamada `paletteRam` en `PPUMemory`
  - el array debería almacenar 32 bytes
  - 📚  mapea el rango $3F00-$3F1F a Palette RAM (tanto lecturas como escrituras)
  - |-
    📚  implementa este método en `PPU`:
    **getColor(paletteId, colorIndex)**:
      **->** calcula la dirección inicial de la paleta:
        `0x3F00 + paletteId * 4`
        (llamemos a esto `startAddress`)
      **->** lee el índice de color de la memoria:
        lee desde la dirección PPU ```javascript startAddress + colorIndex```
        (llamemos a esto `masterColorIndex`)
      **->** devuelve un color de la paleta maestra, usando `masterColorIndex`
        (puedes importar y usar 📄  ~/lib/ppu/masterPalette.js~ para la lista de colores)
  - |-
    📚  implementa este método en `BackgroundRenderer`:
    **_getPaletteId(nameTableId, x, y)**:
      **->** agrega el código necesario para devolver el id de paleta correcto para el píxel ~(x, y)~
      **->** sigue 📄  ~/docs/ppu/background_rendering.es.md~ para orientación sobre cómo se codifican los ids de paletas
  - |-
    📚  cambia `BackgroundRenderer::renderScanline()` para que use `_getPaletteId(...)` y dibuje el color correcto, así:
      ```javascript
      const paletteId = this._getBackgroundPaletteId(nameTableId, x, y);

      const tileInsideY = y % 8;

      const tile = new Tile(this, patternTableId, tileId, tileInsideY);
      for (let xx = 0; xx < 8; xx++) {
        const colorIndex = tile.getColorIndex(xx);
        const color =
          colorIndex > 0 ? this.ppu.getColor(paletteId, colorIndex) : this.ppu.getColor(0, 0);
        this.plot(x + xx, y, color);
      }```
  - ten en cuenta que cuando el índice de color es 0, se renderiza un <color de fondo> en su lugar (ubicado en el primer índice de la primera paleta)
  responses:
  - "\"¿agrega el código necesario\"? ¿en serio? ¿eso es todo? [help]"

help:
  messages:
  - ¿qué, necesitas ayuda? 🤣
  - bueno... estoy escuchando
  responses:
  - ayúdame con las matemáticas 🔢 [math]
  - ¿cuál es el color de fondo? 💧 [backdrop]

math:
  messages:
  - 🔍  primero, basado en el punto ~(x, y)~, necesitas saber en qué <metabloque> estás
  - un <metabloque> es ~2x2 bloques~, ~4x4~ tiles, o ~32x32~ píxeles (como quieras verlo)
  - así que ```javascript Math.floor(x / 32)``` y ```javascript Math.floor(y / 32)``` te darán números que puedes llamar `metablockX` y `metablockY`
  - ya que esto es una matriz, para calcular el `metablockIndex` puedes hacer ```javascript metablockY * 8 + metablockX```
  - (multiplicamos por 8 porque hay 8 metabloques por fila)
  - |-
    📖  con este `metablockIndex`, puedes leer el `block`:
      ```javascript this.ppu.memory.read(startAddress + metablockIndex);```
  - (`startAddress` sería la dirección inicial de la 🖍️ 📖  attribute table, también conocida como los últimos 64 bytes de la 🏞️ 📖  name table)
  - 🔍  con este `block`, basado en el punto ~(x, y)~, ahora necesitas saber en qué <block> estás
  - |-
    un <block> es ~2x2~ tiles o ~16x16~ píxeles, por lo tanto:
      ```javascript
      const blockX = Math.floor((x % 32) / 16);
      const blockY = Math.floor((y % 32) / 16);
      const blockIndex = blockY * 2 + blockX;```
  - 🕵️  con este `blockIndex`, puedes tomar los bits requeridos de `block` usando `byte.getBits(...)`
  - (necesitas leer 2 bits, comenzando desde el bit `blockIndex * 2`)
  - ¡y eso te dará el `paletteId` de ese punto ~(x, y)~!
  responses:
  - uff [oof]

oof:
  messages:
  - síii... la vida es dura 😅
  - bueno, ¡buena suerte!
  responses: []

backdrop:
  messages:
  - puedes pensar en ello como un color "transparente" global
  - el índice 0 de cada paleta lo usará, y está definido en ~paleta 0, índice 0~ (también conocido como ~PPU $3F00~)
  responses:
  - ...help
