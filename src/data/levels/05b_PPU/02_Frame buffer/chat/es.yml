---
main:
  run: |
    {{Top}}.load("frameBuffer.png");
  messages:
  - almacenaremos nuestros datos de imagen en algo llamado frame buffer
  - es básicamente una gran matriz con el color de cada píxel
  - cada elemento es un número de 32 bits __$aabbggrr__
  - "\"aa\" representa la opacidad (en nuestra NEEES siempre es $FF)"
  - "\"bb\", \"gg\" and \"rr\" representan la cantidad de <azul>, <verde> y <rojo>"
  responses:
  - (*) ¿puedes darme algunos ejemplos de colores? [examples]
  - ¡quiero dibujar algo en la pantalla! 🖌️ [integrate]

examples:
  messages:
  - "aquí tienes algunos colores de ejemplo:"
  - "❤️  ```javascript 0xFF0000FF``` = rojo"
  - "💚  ```javascript 0xFF00FF00``` = verde"
  - "💙  ```javascript 0xFFFF0000``` = azul"
  - "⚪  ```javascript 0xFFFFFFFF``` = blanco"
  - "🖤  ```javascript 0xFF000000``` = negro"
  - "🦈  ```javascript 0xFF989898``` = gris"
  - "💛  ```javascript 0xFF00F8F8``` = amarillo"
  responses:
  - ...main

integrate:
  run: |
    {{Top}}.load(null, "rom");
  messages:
  - primero que nada, voy a integrar tu 🖥️  PPU en el emulador
  - debería ser rápido...
  run-after-messages: |
    level.startEffect("earthquake");
    setTimeout(() => {
      bus.emit("patching-end");
    }, 500);
  events: 
  - patching-end [done]

done:
  run: |
    level.stopEffect();
    book.unlock("usePPU");
  messages:
  - ✅  ¡listo!
  - <! 🖥️  PPU integrada.
  - ahora, el ícono 🖥️  en el emulador brillará ✨
  - como casi no hay código PPU, por ahora no se mostrará nada
  - ¡pero llegaremos allí!
  responses:
  - programemos esto 🤟 [exercise]

exercise:
  run: |
    {{Top}}.load(null, "rom");
  messages:
  - |-
    📚  ok, vamos a agregar esto al constructor de tu PPU:
      ```javascript
      this.frameBuffer = new Uint32Array(256*240);```
  - |-
    📚  implementa este método:
    **plot(x, y, color)**:
      **->** asigna el `color` al píxel ~(x,y)~ en el array `frameBuffer`
        (el índice para ~(x,y)~ debería ser ```javascript y * 256 + x```)
  - 📚  luego, modifica tu método `step` para que reciba un callback `onFrame` como parámetro
  - |-
    📚  y cada vez que detectes un nuevo frame (justo después de ```javascript this.frame++;```), llámalo con el frame buffer, así:
      ```javascript onFrame(this.frameBuffer);```
  - |-
    📚  para asegurarnos de que todo funciona correctamente, agrega este código antes de la llamada a `onFrame`:
      ```javascript
      // <test>
      for (let x = 0; x < 256; x++) {
        for (let y = 0; y < 240; y++) {
          this.plot(x, y, 0xff000000 | this.frame % 256);
        }
      }
      // </test>```
  - ¡pruébalo! al iniciar una ROM, debería lentamente pintar la pantalla de rojo 🔴
  responses: []
