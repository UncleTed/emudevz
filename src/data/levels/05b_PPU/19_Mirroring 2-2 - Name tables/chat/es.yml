main:
  messages:
  - el mapa de memoria de la PPU tiene una secci√≥n dedicada para 4 name tables, en ~PPU $2000-$2FFF~
  - cada name table es de 1024 bytes (o $400 en hexadecimal), por lo que estas 4 tablas est√°n en las direcciones $2000, $2400, $2800 y $2C00
  - pero el hardware real de la NEEES solo tiene VRAM para <dos> de ellas
  - lo que termina sucediendo es que el mapper espeja las otras de formas divertidas ‚ú®
  - y ese espejado ("mirroring") es √∫til para que los juegos implementen scrolling
  - revis√©moslas
  responses:
  - genial, a ver üëÄ [show]

show:
  messages:
  - llamemos a las name tables "f√≠sicas" (las que realmente podemos almacenar en VRAM) "A" y "B"
  - el mirroring "HORIZONTAL" conecta $2000 y $2400 a la primera name table f√≠sica ("A") y $2800 y $2C00 a la segunda name table f√≠sica ("B")
  - <{horizontal.png}>
  - ¬øentiendes? est√°n reflejadas horizontalmente üòâ
  responses:
  - ¬°s√≠! [vertical]

vertical:
  messages:
  - el mirroring "VERTICAL" conecta $2000 a "A" y $2400 a "B", luego repite todo en $2800 y $2C00"
  - <{vertical.png}>
  - y ahora est√°n reflejadas verticalmente üòä
  responses:
  - claro [single]

single:
  messages:
  - tambi√©n hay juegos que usan una √∫nica name table, repetida 4 veces (dejando la otra name table f√≠sica sin usar)
  - <{single.png}>
  - dependiendo del mapper, esto tambi√©n podr√≠a ser "B" cuatro veces
  - llamamos al primero "ONE_SCREEN_LOWER_BANK" y al segundo "ONE_SCREEN_UPPER_BANK"
  responses:
  - tiene sentido [fourscreen]

fourscreen:
  messages:
  - finalmente, hay algunos cartuchos de juegos que contienen RAM extra para 2 name tables f√≠sicas adicionales
  - lo que les permite usar una configuraci√≥n "FOUR_SCREEN"
  - <{4screen.png}>
  - esta es la raz√≥n por la que definimos nuestra propiedad `vram` como un array de 4096 bytes en `PPUScreen`
  responses:
  - implementemos esto [implement]

implement:
  messages:
  - traduje los tipos de mapeo en una linda tabla aqu√≠ üìÑ  ~/lib/ppu/mirroringTypes.js~
  - las claves (`$2000`, `$2400`, `$2800` y `$2C00`) representan las direcciones l√≥gicas de la PPU
  - y los valores (principalmente `0x000` y `0x400`) son los desplazamientos de las name tables f√≠sicas dentro del array `PPUMemory::vram`
  - üìö  _-_en `PPUMemory`, importa el archivo `mirroringTypes`_--_
  - |-
    üìö  _-_define este m√©todo:_--_
    *_-_*changeNameTableMirroringTo(mirroringId)**:_--_
      *_-_*->** si ~this.cartridge.header.mirroringId === "FOUR_SCREEN"~_--_
        *_-_*->** asigna ~mirroringId = "FOUR_SCREEN"~_--_
      *_-_*->** asigna ~this.mirroringId = mirroringId~_--_
      *_-_*->** asigna ~this._mirroring = mirroringTypes[mirroringId]~_--_
      _-_(los mappers llamar√°n a este m√©todo para cambiar el tipo de mirroring cuando lo necesiten)_--_
  - üìö  _-_cambia `onLoad(...)` para que llame al nuevo m√©todo con el mirroring inicial (recuerda que esto est√° guardado en `cartridge.header.mirroringId`)_--_
  - üìö  _-_mapea los rangos $2000-$23FF, $2400-$27FF, $2800-$2BFF y $2C00-$2FFF a VRAM, basado en el `mirroring` actual (tanto lecturas como escrituras)_--_
  responses:
  - ¬øpor ejemplo? üßê [example]

example:
  messages:
  - busca la secci√≥n "Name tables 0 to 3 (VRAM + mirror)" en ambos m√©todos `read(...)` y `write(...)`
  - |-
    actualmente, `read(...)` deber√≠a verse as√≠:
    ```javascript
    if (address >= 0x2000 && address <= 0x2fff)
      return this.vram[address - 0x2000];
    ```
  - necesitas mapear las 4 secciones seg√∫n a d√≥nde apunte `this._mirroring`
  - |-
    implementemos los primeros dos casos
    ```javascript
    if (address >= 0x2000 && address <= 0x2fff) {
      if (address >= 0x2000 && address < 0x2400)
        return this.vram[this._mirroring.$2000 + (address - 0x2000)];
      if (address >= 0x2400 && address < 0x2800)
        return this.vram[this._mirroring.$2400 + (address - 0x2400)];
      // TODO: ¬°Termina los dem√°s!
    }
    ```
  responses: []
