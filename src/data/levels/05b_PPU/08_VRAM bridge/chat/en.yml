---
main:
  messages:
  - games define, at runtime, how the background should look 🏞️
  - they create a map using tiles, and store it in 🐏  VRAM
  responses:
  - how can a game write to 🐏  VRAM? [how]

how:
  messages:
  - through the video registers called 📍  ~PPUAddr~ and 📦  ~PPUData~
  - they are like a bridge that connects the 🧠  CPU and 🖥️  PPU
  - first, games put the VRAM address they want to write in 📍  ~PPUAddr~
  - "(two consecutive writes: one for the <high byte>, and one for the <low byte>)"
  - then, they write to 📦  ~PPUData~ the byte they want to put in that address
  - <{PPUAddr_PPUData.png}>
  responses:
  - nice, I guess I need to define the VRAM somewhere [define]

define:
  messages:
  - yeah, better start with that
  - 📚  like you did with `CPUMemory::ram`, add a property called `vram` in `PPUMemory`
  - the array should store 4096 bytes
  - (I know I said multiple times that there's only 2 KiB of VRAM, but some games extend that memory using extra chips in their cartridge, and it's easier to emulate those by just allocating a big 4 KiB chunk 🤷 )
  - 📚  map the range $2000-$2FFF to VRAM (both reads and writes)
  - |-
    📚  implement these methods in `PPUAddr`:
    **onLoad()**:
      **->** initializes two properties:
        `this.latch = false`
        `this.address = 0`
        (we'll use these to model the alternating behavior between high byte / low byte on every write operation)
    **onWrite(value)**:
      **->** if `latch` is ```javascript false```:
        **->** writes only the high byte of `address`, using `value`
          (leave the low part as it was before)
      **->** if it's ```javascript true```:
        **->** writes only the low byte of `address`, using `value`
          (leave the high part as it was before)
      (you can use `buildU16(...)`, `highByteOf(...)`, and `lowByteOf(...)`)
      **->** switches `latch` to the opposite value
  - |-
    📚  implement these methods in `PPUData`:
    **onWrite(value)**:
      **->** writes `value` to the PPU memory address `ppuAddr.address`
        (you can access the `PPUMemory` instance with `this.ppu.memory`)
        (you can access the `PPUAddr` instance with `this.ppu.registers.ppuAddr`)
      **->** calls `this._incrementAddress()`
    **_incrementAddress()**:
      **->** if `ppuCtrl.vramAddressIncrement32` is ~1~:
        **->** increments `ppuAddr.address` by 32
      **->** if not:
        **->** increments `ppuAddr.address` 1 time
     **[!]** make sure the address never exceeds 65535 by using `byte.toU16(...)`
  - |-
    📚  lastly, modify in `PPUStatus`:
    **onRead()**:
      **->** after resetting `isInVBlankInterval`, it also resets the `latch` from `PPUAddr`
  responses:
  - what's this address increment? 🤔 [increment]

increment:
  messages:
  - yeah, I forgot to tell you
  - the PPU increments the address automatically after writing to 📦  PPUData
  - depending on what's in 🎛️  ~PPUCtrl~, this can be a ~+1~ or a ~+32~
  responses: []
