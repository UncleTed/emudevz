---
main:
  messages:
  - los juegos definen, en tiempo de ejecución, cómo debe lucir el fondo 🏞️
  - crean un mapa usando tiles y lo almacenan en la 🐏  VRAM
  responses:
  - ¿cómo puede un juego escribir en la 🐏  VRAM? [how]

how:
  messages:
  - a través de los registros de video llamados 📍  ~PPUAddr~ y 📦  ~PPUData~
  - son como un puente que conecta la 🧠  CPU y 🖥️  PPU
  - primero, los juegos ponen la dirección de VRAM que quieren escribir en 📍  ~PPUAddr~
  - "(dos escrituras consecutivas: una para el <high byte>, y una para el <low byte>)"
  - luego, escriben en 📦  ~PPUData~ el byte que quieren poner en esa dirección
  - <{PPUAddr_PPUData.png}>
  responses:
  - bien, supongo que necesito definir la VRAM en algún lugar [define]

define:
  messages:
  - sí, mejor empieza por eso
  - 📚  como hiciste con `CPUMemory::ram`, agrega una propiedad llamada `vram` en `PPUMemory`
  - el array debería almacenar 4096 bytes
  - (sé que dije varias veces que solo hay 2 KiB de VRAM, pero algunos juegos extienden esa memoria usando chips extra en su cartucho, y es más fácil emular esos simplemente asignando un gran bloque de 4 KiB 🤷 )
  - 📚  mapea el rango $2000-$2FFF a VRAM (tanto lecturas como escrituras)
  - |-
    📚  implementa estos métodos en `PPUAddr`:
    **onLoad()**:
      **->** inicializa dos propiedades:
        `this.latch = false`
        `this.address = 0`
        (usaremos estas para modelar el comportamiento alternante entre byte alto / byte bajo en cada operación de escritura)
    **onWrite(value)**:
      **->** si `latch` es `false`:
        **->** escribe solo el high byte de `address`, usando `value`
          (deja la parte baja como estaba antes)
      **->** si es `true`:
        **->** escribe solo el low byte de `address`, usando `value`
          (deja la parte alta como estaba antes)
      (puedes usar `buildU16(...)`, `highByteOf(...)`, y `lowByteOf(...)`)
      **->** cambia `latch` al valor opuesto
  - |-
    📚  implementa estos métodos en `PPUData`:
    **onWrite(value)**:
      **->** escribe `value` en la dirección de memoria PPU `ppuAddr.address`
        (puedes acceder a la instancia `PPUMemory` con `this.ppu.memory`)
        (puedes acceder a la instancia `PPUAddr` con `this.ppu.registers.ppuAddr`)
      **->** llama a `this._incrementAddress()`
    **_incrementAddress()**:
      **->** si `ppuCtrl.vramAddressIncrement32` es ~1~:
        **->** incrementa `ppuAddr.address` por 32
      **->** si no:
        **->** incrementa `ppuAddr.address` 1 vez
     **[!]** asegúrate de que la dirección nunca exceda 65535 usando `byte.toU16(...)`
  - |-
    📚  por último, modifica en `PPUStatus`:
    **onRead()**:
      **->** luego de resetear `isInVBlankInterval`, también resetea el `latch` de `PPUAddr`
  responses:
  - ¿qué es este incremento de dirección? 🤔 [increment]

increment:
  messages:
  - sí, olvidé mencionarte
  - la PPU incrementa la dirección automáticamente después de escribir en 📦  PPUData
  - dependiendo de lo que esté en 🎛️  ~PPUCtrl~, esto puede ser un ~+1~ o un ~+32~
  responses: []
