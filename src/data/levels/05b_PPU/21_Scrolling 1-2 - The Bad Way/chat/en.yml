main:
  messages:
  - scrolling is a PPU feature that allows developers to move the background
  - implementing it in a NEEES emulator is hard ü•µ
  - not because it's hard to move the background, but because the scroll registers behave in non-obvious ways
  - a lot of people have tried, but only the chosen ones were able to do it
  responses:
  - do you have a plan? [plan]
  - <<level.isCompleted || m.$exercise>> üìö  take me to the action [proceed]

plan:
  messages:
  - yeah, we can do it together
  - I'll try to help you by abstracting the tricky parts into a library
  - it will take a while
  - in the meantime, you can add a basic implementation of scrolling that won't work for all games
  - but it will be fine for the majority of them!
  responses:
  - sounds good, how does scrolling work? [good]

good:
  messages:
  - well, the games don't actually move <the background>
  - they move an imaginary viewport against the static background
  - that's enough to create the idea of movement üåÄ
  responses:
  - and how does the viewport move? [viewport]

viewport:
  messages:
  - like this
  - <{3rdparty_nametable_scrolling.png}>
  - games write into üìú  PPUScroll the position of the viewport
  - they write twice, first for the <X coordinate>, then for the <Y coordinate>
  - and the PPU moves the viewport, only drawing part of the affected name tables
  responses:
  - so... if games write twice, the PPU has to remember what coordinate they are setting, right? [twice]

twice:
  messages:
  - exactly
  - remember how üìç  `PPUAddr` works? with a `latch` that is switched after every write?
  - well, like that
  - actually, it uses that same `latch`!
  responses:
  - I see... [isee]

isee:
  messages:
  - first NEEES games only scrolled in one direction
  - games with <horizontal> name table mirroring would only scroll <vertically>
  - and games with <vertical> name table mirroring would only scroll <horizontally>
  - <{3rdparty_vertical_horizontal.png}>
  responses:
  - I don't get it, if there are only two physical name tables, how do games achieve long maps? [long]

long:
  messages:
  - they update background parts progressively when the viewport isn't focused on them
  - btw, the viewport position is based on the <base name table>
  - remember that the first two bits of üéõÔ∏è  `PPUCtrl` select the current name table
  - (you have that mapped as `registers.ppuCtrl.nameTableId`)
  - so, if the base name table is 1, it means that the viewport should start at the name table positioned in $2400
  - <{3rdparty_scrolled_nametables.png}>
  responses:
  - enough talk, how do we proceed? [proceed]

proceed:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - (again, ~THIS IS NOT EXACTLY CORRECT~, but it'll work for now!)
  - |-
    üìö  modify these methods of `PPUScroll`:
      **onLoad()**:
        **->** sets ```javascript this.x = 0```
        **->** sets ```javascript this.y = 0```
      **onWrite(value)**:
        **->** if PPUAddr's `latch` is ```javascript false```:
          **->** writes the `value` to ```javascript this.x```
        **->** if it's ```javascript true```:
          **->** writes the `value` to ```javascript this.y```
        (you can access the `latch` with ```javascript this.ppu.registers.ppuAddr.latch```)
        **->** switches the `latch` to the opposite value
  responses:
  - alright, then what? [then]

then:
  messages:
  - then you will have in ```javascript ppuScroll.x``` and ```javascript ppuScroll.y``` the scroll coordinates!
  - you can apply the scrolling to the backgrounds now!
  - |-
    üìö  go to `BackgroundRenderer` and change `renderScanline()`:
      **->** if you previously had something like...
        ```javascript
          for (let x = 0; x < 256; x += 8)```
      ...replace it with...
        ```javascript
          for (let x = 0; x < 256;)```
      you won't be drawing in 8-pixel chunks anymore, you need to be prepared to draw only a part of certain tiles!
  - |-
    üìö  let's define a few things:
      ```javascript
      // scroll coordinates:
      const scrollX = this.ppu.registers.ppuScroll.x;
      const scrollY = registers.ppuScroll.y;
      // current point to draw:
      const scrolledX = x + scrollX;
      const scrolledY = y + scrollY;
      // base name table address:
      const nameTableId = this.ppu.registers.ppuCtrl.nameTableId;
      const nameTableAddress = 0x2000 + nameTableId * 1024;
      // current point, relative to the name table:
      const nameTableX = scrolledX % 256;
      const nameTableY = scrolledY % 240;```
    
    from now on, every usage of `x` and `y` should be replaced by `nameTableX` and `nameTableY`
    (for example: the name table read index, the ```javascript this._getBackgroundPaletteId(...)``` call, and ```javascript new Tile(...)``` should be updated)
    the only exception is the `plotBG(...)` call, which still needs to plot in the ~(x,y)~ point of the screen
  - |-
    üìö  lastly, define:
      ```javascript
      const tileStartX = nameTableX % 8;
      const tileInsideY = nameTableY % 8;
      const tilePixels = Math.min(
        8 - tileStartX,
        256 - nameTableX
      );```
      
    remember, you won't be drawing 8 pixels per loop iteration anymore, you will only draw `tilePixels`, starting from `tileStartX`
    so, make sure you change the inner loop to something like:
      ```javascript
        for (let xx = 0; xx < tilePixels; xx++)```
    the `getColorIndex` call should use `tileStartX`:
      ```javascript
        tile.getColorIndex(tileStartX + xx);```
    and at the very end, once the inner loop ends, increment the main loop index manually:
      ```javascript
        x += tilePixels;```
  responses: []
