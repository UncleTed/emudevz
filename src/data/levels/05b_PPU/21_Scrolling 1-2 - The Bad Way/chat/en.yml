main:
  messages:
  - scrolling is a PPU feature that allows developers to move the background
  - implementing it in a NEEES emulator is hard ü•µ
  - not because it's hard to move the background, but because the scroll registers behave in odd ways
  - a lot of people have tried, but only the chosen ones were able to do it
  responses:
  - do you have a plan? [plan]
  - <<level.isCompleted || m.$exercise>> üìö  take me to the action [proceed]

plan:
  messages:
  - yeah, we can do it together
  - I'll try to help you by abstracting the tricky parts into a library
  - it will take a while
  - in the meantime, you can add a basic implementation of scrolling that won't work for all games
  - but it will be fine for the majority of them!
  responses:
  - sounds good, how does scrolling work? [good]

good:
  messages:
  - well, the games don't actually move <the background>
  - they move an imaginary viewport against the static background
  - that's enough to create the idea of movement üåÄ
  responses:
  - and how does the viewport move? [viewport]

viewport:
  messages:
  - like this
  - <{3rdparty_nametable_scrolling.png}>
  - games write into üìú  `PPUScroll` the position of the viewport
  - they write twice, first for the <X coordinate>, then for the <Y coordinate>
  - and the PPU moves the viewport, only drawing part of the affected name tables
  responses:
  - so... if games write twice, the PPU has to remember what coordinate they are setting, right? [twice]

twice:
  messages:
  - exactly
  - remember how üìç  `PPUAddr` works? with a `latch` that is switched after every write?
  - well, like that
  - actually, it uses that same `latch`!
  responses:
  - I see... [isee]

isee:
  messages:
  - first NEEES games only scrolled in one direction
  - games with <horizontal> name table mirroring would only scroll <vertically>
  - and games with <vertical> name table mirroring would only scroll <horizontally>
  - <{3rdparty_vertical_horizontal.png}>
  responses:
  - I don't get it, if there are only two physical name tables, how do games achieve long maps? [long]

long:
  messages:
  - they update background parts progressively when the viewport isn't focused on them
  - btw, the viewport position is based on the <base name table>
  - remember that the first two bits of üéõÔ∏è  `PPUCtrl` select the current name table
  - (you have that mapped as `registers.ppuCtrl.nameTableId`)
  - so, if the base name table is 1, it means that the viewport should start at the name table positioned in $2400
  - <{3rdparty_scrolled_nametables.png}>
  responses:
  - enough talk, how do we proceed? [proceed]

proceed:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - (again, THIS IS NOT EXACTLY CORRECT, but it'll work for now!)
  - |-
    üìö  _-_modify these methods of `PPUScroll`:_--_
      *_-_*onLoad()**:_--_
        *_-_*->** sets ~this.x = 0~_--_
        *_-_*->** sets ~this.y = 0~_--_
      *_-_*onWrite(value)**:_--_
        *_-_*->** if PPUAddr's ~latch~ is ~false~:_--_
          *_-_*->** writes the ~value~ to ~this.x~_--_
        *_-_*->** if it's ~true~:_--_
          *_-_*->** writes the ~value~ to ~this.y~_--_
        _-_(you can access the ~latch~ with ~this.ppu.registers.ppuAddr.latch~)_--_
        *_-_*->** switches the ~latch~ to the opposite value_--_
  responses:
  - alright, then what? [then]

then:
  messages:
  - then you will have in ~ppuScroll.x~ and ~ppuScroll.y~ the scroll coordinates!
  - you can apply the scrolling to the backgrounds now!
  - |-
    üìö  _-_go to `BackgroundRenderer` and change `renderScanline()`:
      *_-_*->** if you previously had something like...
        ```javascript
          for (let x = 0; x < 256; x += 8)```
      ...replace it with...
        ```javascript
          for (let x = 0; x < 256;)```
      you won't be drawing in 8-pixel chunks anymore, you need to be prepared to draw only a part of certain tiles!_--_
  - |-
    üìö  _-_let's define a few things:
      ```javascript
      // scroll coordinates:
      const scrollX = this.ppu.registers.ppuScroll.x;
      const scrollY = registers.ppuScroll.y;
      // current point to draw:
      const scrolledX = x + scrollX;
      const scrolledY = y + scrollY;
      // base name table address:
      const nameTableId = this.ppu.registers.ppuCtrl.nameTableId;
      const scrolledNameTableId = nameTableId + Math.floor(scrolledX / 256) + Math.floor(scrolledY / 240) * 2;
      const nameTableAddress = 0x2000 + scrolledNameTableId * 1024;
      // current point, relative to the name table:
      const nameTableX = scrolledX % 256;
      const nameTableY = scrolledY % 240;```
    
    from now on, every usage of ~x~ and ~y~ should be replaced by ~nameTableX~ and ~nameTableY~
    (for example: the name table read index, the `this._getBackgroundPaletteId(...)` call, and `new Tile(...)` should be updated)
    the only exception is the `plotBG` call, which still needs to plot in the ~(x,y)~ point of the screen_--_
  - |-
    üìö  _-_lastly, define:
      ```javascript
      const tileStartX = nameTableX % 8;
      const tileStartY = nameTableY % 8;
      const tilePixels = Math.min(
        8 - tileStartX,
        256 - nameTableX
      );```
    
    remember, you won't be drawing 8 pixels per loop iteration anymore, you will only draw `tilePixels`
    so, make sure you change the inner loop to something like:
      ```javascript
        for (let xx = 0; xx < tilePixels; xx++)```
    and at the very end, increment the main loop index manually:
      ```javascript
        x += tilePixels;```_--_
  responses: []
