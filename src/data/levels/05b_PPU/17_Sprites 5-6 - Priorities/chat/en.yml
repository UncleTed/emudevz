main:
  messages:
  - as we saw in the <sprite evaluation>, sprites with lower OAM indices are drawn in front
  - additionally, there's the <sprite-to-background> priority bit (byte 2, bit 5), which makes the sprites appear behind the background
  - when the background covers a sprite, only opaque pixels are taken into account
  responses:
  - show me an example [example]

example:
  run: |-
    {{Top}}.load("SuperTiltBro.neees", "rom", "bin");
  messages:
  - take a look at the <cloud> in the middle
  - the cloud is a sprite and the game title is part of the background
  - at some point, it covers the "TILT" and "BRO" words, while it should be behind them
  - this is because we are not using the correct sprite priorities
  - and BrokenNEEES got it wrong too, so it doesn't matter which PPU you use!
  responses:
  - how can we fix it? [fix]

fix:
  messages:
  - first, we need to remember which background pixels are transparent
  - that is, when the <color index> is 0
  - then, we'll save current scanline's colors and sprites into a temporary buffer
  - and we'll only plot the pixels from that buffer if the sprite priority is <front> or the background pixel is transparent
  responses:
  - sounds clear enough [clear]

clear:
  messages:
  - |-
    ðŸ“š  alright, in the `PPU` class, add to the constructor:
      ```javascript
      this.colorIndexes = new Uint8Array(256*240);```
  - |-
    ðŸ“š  implement these methods:
    **plotBG(x, y, color, colorIndex)**:
      **->** saves the `colorIndex`:
        ```javascript this.colorIndexes[y * 256 + x] = colorIndex;```
      **->** draws the pixel:
        ```javascript this.plot(x, y, color);```
    **isBackgroundPixelOpaque(x, y)**:
      **->** returns whether the ~(x, y)~ pixel in `colorIndexes` is greater than 0
  - ðŸ“š  in `BackgroundRenderer`, instead of calling the `plot` method, call `plotBG` passing the `colorIndex` as the last argument
  - |-
    ðŸ“š  in `SpriteRenderer`, modify these methods:
      **_render(...)**:
        **->** at the start, declare a `buffer` empty array
        **->** instead of calling `this.ppu.plot(...)`, save the information in the `buffer`:
          ```javascript const x = sprite.x + insideX;```
          ```javascript const color = paletteColors[colorIndex];```
          ```javascript buffer[x] = { x, sprite, color };```
        **->** at the end, ```javascript return buffer;```
      **renderScanline()**:
        **->** assigns the return value of `this._render(sprites)` to a `buffer` constant
        **->** calls `this._draw(buffer);`
  - |-
    ðŸ“š  and define:
      **_draw(buffer)**:
        **->** determine the y coordinate:
          ```javascript this.ppu.scanline;```
          (let's call this `y`)
        **->** for each `element` in the `buffer` array:
          **->** if the `element` is not `undefined`:
            **->** determine if the sprite is in front of background:
              ```javascript element.sprite.isInFrontOfBackground;```
              (let's call this `isInFront`)
            **->** determine if the corresponding background pixel is opaque:
              ```javascript this.ppu.isBackgroundPixelOpaque(element.x, y);```
              (let's call this `isBGOpaque`)
            **->** if `isInFront || !isBGOpaque`:
              **->** call ```javascript this.ppu.plot(element.x, y, element.color);```
  responses: []
