main:
  messages:
  - as we saw in the sprite evaluation, sprites with lower OAM indexes are drawn in <front>
  - additionally, there's the <sprite-to-background> priority bit (byte 2, bit 5), which makes the sprites appear <behind> the background
  - when the background covers a sprite, only opaque pixels are taken into account
  responses:
  - show me an example [example]

example:
  run: |
    {{Top}}.loadROM("/roms/.all/SuperTiltBro.neees");
  messages:
  - take a look at the <cloud> in the middle
  - the cloud is a sprite and the game title is part of the background
  - at some point, it covers the "TILT" and "BRO" words, while it should be behind them
  - this is because we are not using the correct sprite priorities
  - and BrokenNEEES got it wrong too, so it doesn't matter which PPU you use!
  responses:
  - how can we fix it? [fix]

fix:
  messages:
  - first, we need to remember which background pixels are transparent
  - that is, when the color index is 0
  - then, we'll save current scanline's colors and sprites into a temporary buffer
  - and we'll only plot the pixels from that buffer if the sprite priority is <front> or the background pixel is transparent
  responses:
  - sounds clear enough [exercise]

exercise:
  messages:
  - |-
    📚  alright, in the 🖥️  `PPU` class, add to the constructor:
      ```javascript
      this.colorIndexes = new Uint8Array(256*240);```
  - |-
    📚  implement these methods:
    **plotBG(x, y, color, colorIndex)**:
      **->** saves the `colorIndex`:
        ```javascript this.colorIndexes[y * 256 + x] = colorIndex;```
      **->** draws the pixel:
        ```javascript this.plot(x, y, color);```
    **isBackgroundPixelOpaque(x, y)**:
      **->** returns whether the ~(x, y)~ pixel in `colorIndexes` is greater than 0 or not
  - 📚  in 🏞️  `BackgroundRenderer`, instead of calling the `plot(...)` method, call `plotBG(...)` passing the `colorIndex` as the last argument
  - |-
    📚  in 🛸  `SpriteRenderer`, <modify> these methods:
      **_render(...)**:
        **->** at the start, declare a `buffer` empty array
        **->** instead of calling ```javascript this.ppu.plot(...)```, save the information in the `buffer`:
          ```javascript const x = sprite.x + insideX;```
          ```javascript const color = paletteColors[colorIndex];```
          ```javascript buffer[x] = { x, sprite, color };```
        **->** at the end, ```javascript return buffer;```
      **renderScanline()**:
        **->** assigns the return value of ```javascript this._render(sprites)``` to a `buffer` constant
        **->** calls ```javascript this._draw(buffer);```
  - |-
    📚  and define:
      **_draw(buffer)**:
        **->** determine the y coordinate:
          ```javascript this.ppu.scanline;```
          (let's call this `y`)
        **->** for each `element` in the `buffer` array:
          **->** if the `element` is not ```javascript undefined```:
            **->** determine if the sprite is in front of background:
              ```javascript element.sprite.isInFrontOfBackground;```
              (let's call this `isInFront`)
            **->** determine if the corresponding background pixel is opaque:
              ```javascript this.ppu.isBackgroundPixelOpaque(element.x, y);```
              (let's call this `isBGOpaque`)
            **->** if ```javascript isInFront || !isBGOpaque```:
              **->** calls ```javascript this.ppu.plot(element.x, y, element.color);```
  responses: []

corollary:
  messages:
  - if you run 🦸 🤸  ~Super Tilt Bro~, you'll see that now the clouds render properly 🙂
  responses:
  - ▶️  continue [end]
