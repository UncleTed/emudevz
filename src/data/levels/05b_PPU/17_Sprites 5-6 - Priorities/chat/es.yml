main:
  messages:
  - como vimos en la evaluaci√≥n de sprites, los sprites con √≠ndices OAM m√°s bajos se dibujan al <frente>
  - adem√°s, est√° el bit de prioridad <sprite-to-background> (byte 2, bit 5), que hace que los sprites aparezcan <detr√°s> del fondo
  - cuando el fondo cubre un sprite, solo se toman en cuenta los p√≠xeles opacos
  responses:
  - mu√©strame un ejemplo [example]

example:
  run: |
    {{Top}}.loadROM("/roms/.all/SuperTiltBro.neees");
  messages:
  - presta atenci√≥n a la <nube> en el medio
  - la nube es un sprite y el t√≠tulo del juego es parte del fondo
  - llegado a un punto, cubre las palabras "TILT" y "BRO", cuando deber√≠a estar detr√°s de ellas
  - esto es porque no estamos usando las prioridades correctas de los sprites
  - y BrokenNEEES tambi√©n lo hizo mal, ¬°as√≠ que no importa qu√© PPU uses!
  responses:
  - ¬øc√≥mo podemos arreglarlo? [fix]

fix:
  messages:
  - primero, necesitamos recordar qu√© p√≠xeles del fondo son transparentes
  - es decir, cuando el √≠ndice de color es 0
  - luego, guardaremos los colores y sprites de la scanline actual en un buffer temporal
  - y solo dibujaremos los p√≠xeles de ese buffer si la prioridad del sprite es <front> o si el p√≠xel del fondo es transparente
  responses:
  - suena bastante claro [clear]

clear:
  messages:
  - |-
    üìö  de acuerdo, en la clase üñ•Ô∏è  `PPU`, agrega al constructor:
      ```javascript
      this.colorIndexes = new Uint8Array(256*240);```
  - |-
    üìö  implementa estos m√©todos:
    **plotBG(x, y, color, colorIndex)**:
      **->** guarda el `colorIndex`:
        ```javascript this.colorIndexes[y * 256 + x] = colorIndex;```
      **->** dibuja el p√≠xel:
        ```javascript this.plot(x, y, color);```
    **isBackgroundPixelOpaque(x, y)**:
      **->** devuelve si el p√≠xel ~(x, y)~ en `colorIndexes` es mayor que 0
  - üìö  en üèûÔ∏è  `BackgroundRenderer`, en lugar de llamar al m√©todo `plot(...)`, llama a `plotBG(...)` pasando el `colorIndex` como √∫ltimo argumento
  - |-
    üìö  en üõ∏  `SpriteRenderer`, modifica estos m√©todos:
      **_render(...)**:
        **->** al inicio, declara un `buffer` como un array vac√≠o
        **->** en lugar de llamar a ```javascript this.ppu.plot(...)```, guarda la informaci√≥n en el `buffer`:
          ```javascript const x = sprite.x + insideX;```
          ```javascript const color = paletteColors[colorIndex];```
          ```javascript buffer[x] = { x, sprite, color };```
        **->** al final, ```javascript return buffer;```
      **renderScanline()**:
        **->** asigna el valor devuelto por ```javascript this._render(sprites)``` a una constante `buffer`
        **->** llama a ```javascript this._draw(buffer);```
  - |-
    üìö  y define:
      **_draw(buffer)**:
        **->** determina la coordenada y:
          ```javascript this.ppu.scanline;```
          (llamemos a esto `y`)
        **->** para cada `element` en el array `buffer`:
          **->** si el `element` no es ```javascript undefined```:
            **->** determina si el sprite est√° al frente del fondo:
              ```javascript element.sprite.isInFrontOfBackground;```
              (llamemos a esto `isInFront`)
            **->** determina si el p√≠xel correspondiente del fondo es opaco:
              ```javascript this.ppu.isBackgroundPixelOpaque(element.x, y);```
              (llamemos a esto `isBGOpaque`)
            **->** si ```javascript isInFront || !isBGOpaque```:
              **->** llama a ```javascript this.ppu.plot(element.x, y, element.color);```
  responses: []
