main:
  messages:
  - el scrolling es una característica de la PPU que permite a los desarrolladores mover el fondo
  - implementarlo en un emulador NEEES es difícil 🥵
  - no porque sea difícil mover el fondo, sino porque los registros de desplazamiento se comportan de maneras no obvias
  - mucha gente lo ha intentado, pero solo los elegidos pudieron lograrlo
  responses:
  - ¿tienes un plan? [plan]

plan:
  messages:
  - sí, podemos hacerlo juntos
  - intentaré ayudarte al abstraer las partes complicadas en una biblioteca
  - tomará un tiempo
  - mientras tanto, puedes agregar una implementación básica del scrolling que no funcionará para todos los juegos
  - ¡pero será suficiente para la mayoría de ellos!
  responses:
  - suena bien, ¿cómo funciona el scrolling? [good]

good:
  run: |
    {{Top}}.load("scrolling.gif");
  messages:
  - bueno, los juegos en realidad no mueven <el fondo>
  - mueven una ventana imaginaria contra el fondo estático
  - eso es suficiente para crear la idea de movimiento 🌀
  responses:
  - ¿y cómo se mueve la ventana? [viewport]

viewport:
  messages:
  - así
  - <{3rdparty_nametable_scrolling.png}>
  - los juegos escriben en 📜  PPUScroll la posición de la ventana
  - escriben dos veces, primero para la <coordenada X>, luego para la <coordenada Y>
  - y la PPU mueve la ventana, dibujando solo parte de las name tables afectadas
  responses:
  - entonces... si los juegos escriben dos veces, la PPU tiene que recordar qué coordenada están configurando, ¿cierto? [twice]

twice:
  messages:
  - exacto
  - ¿recuerdas cómo funciona 📍  `PPUAddr`? ¿con un `latch` que cambia después de cada escritura?
  - bueno, así
  - ¡de hecho, usa ese mismo `latch`!
  responses:
  - entiendo... [isee]

isee:
  messages:
  - los primeros juegos de NEEES solo se desplazaban en una dirección
  - los juegos con <mirroring horizontal> de name tables solo se desplazaban <verticalmente>
  - y los juegos con <mirroring vertical> de name tables solo se desplazaban <horizontalmente>
  - <{3rdparty_vertical_horizontal.png}>
  responses:
  - no entiendo, si solo hay dos name tables físicas, ¿cómo logran los juegos tener mapas largos? [long]

long:
  messages:
  - actualizan partes del fondo progresivamente cuando la ventana no está enfocada en ellas
  - por cierto, la posición de la ventana se basa en la <name table base>
  - recuerda que los primeros dos bits de 🎛️  `PPUCtrl` seleccionan la name table actual
  - (tienes eso mapeado como `registers.ppuCtrl.nameTableId`)
  - así que, si la name table base es 1, significa que la ventana debería comenzar en la name table posicionada en $2400
  - <{3rdparty_scrolled_nametables.png}>
  responses:
  - suficiente charla, ¿cómo procedemos? [exercise]

exercise:
  run: |
    {{Top}}.load(null, "rom");
  messages:
  - (de nuevo, ~ESTO NO ES EXACTAMENTE CORRECTO~, ¡pero funcionará por ahora!)
  - |-
    📚  implementa estos métodos de 📜  `PPUScroll`:
      **onLoad()**:
        **->** asigna ```javascript this.x = 0```
        **->** asigna ```javascript this.y = 0```
      **onWrite(value)**:
        **->** si el `latch` de 📍  PPUAddr es ```javascript false```:
          **->** escribe el `valor` en ```javascript this.x```
        **->** si es ```javascript true```:
          **->** escribe el `valor` en ```javascript this.y```
        (puedes acceder al `latch` con ```javascript this.ppu.registers.ppuAddr.latch```)
        **->** cambia el `latch` al valor opuesto
  responses:
  - bien, ¿y después qué? [then]

then:
  messages:
  - tendrás en ```javascript ppuScroll.x``` y ```javascript ppuScroll.y``` las coordenadas de desplazamiento
  - ¡ahora puedes aplicar el scrolling a los fondos!
  - |-
    📚  ve a 🏞️  `BackgroundRenderer` y <cambia> `renderScanline()`:
      **->** si antes tenías algo como...
        ```javascript
          for (let x = 0; x < 256; x += 8)```
      ...reemplázalo con...
        ```javascript
          for (let x = 0; x < 256;)```
      ya no dibujarás en bloques de 8 píxeles, debes estar preparado para dibujar solo una parte de ciertos tiles
  - |-
    📚  definamos algunas cosas:
      ```javascript
      // coordenadas de scrolling:
      const scrollX = this.ppu.registers.ppuScroll.x;
      const scrollY = this.ppu.registers.ppuScroll.y;
      // punto actual a dibujar:
      const scrolledX = x + scrollX;
      const scrolledY = y + scrollY;
      // dirección de la name table base:
      const nameTableId = (
        this.ppu.registers.ppuCtrl.nameTableId +
        (scrolledX >= 256 ? 1 : 0) + // mover a la derecha
        (scrolledY >= 240 ? 2 : 0) // mover abajo
      ) % 4;
      const nameTableAddress = 0x2000 + nameTableId * 1024;
      // punto actual, relativo a la name table:
      const nameTableX = scrolledX % 256;
      const nameTableY = scrolledY % 240;```
    
  - |-
    📚  a partir de ahora, cada uso de `x` y `y` debería ser reemplazado por `nameTableX` y `nameTableY`
      (por ejemplo: el índice de lectura de la name table, la llamada ```javascript this._getBackgroundPaletteId(...)``` y ```javascript new Tile(...)``` deben ser actualizados)
  - la única excepción es la llamada `plotBG(...)`, que aún necesita trazarse en el punto ~(x,y)~ de la pantalla
  - |-
    📚  finalmente, define:
      ```javascript
      const tileStartX = nameTableX % 8;
      const tileInsideY = nameTableY % 8;
      const tilePixels = Math.min(
        8 - tileStartX,
        256 - nameTableX
      );```
  - recuerda, ya no dibujarás 8 píxeles por iteración de bucle, solo dibujarás `tilePixels`, empezando desde `tileStartX`
  - |-
    📚  así que, asegúrate de cambiar el bucle interno a algo como:
      ```javascript
        for (let xx = 0; xx < tilePixels; xx++)```
    la llamada a `getColorIndex(...)` tendría que usar `tileStartX`:
      ```javascript
        tile.getColorIndex(tileStartX + xx);```
    y al final, una vez que el bucle interno termine, incrementa manualmente el índice del bucle principal:
      ```javascript
        x += tilePixels;```
  responses: []

corollary:
  messages:
  - esto debería ser suficiente para tener scrolling en la mayoría de los juegos
  - excepto por ese maldito <plumber game>, que se colgará tan solo después de correr unos pocos metros 🤦
  - pero ignoremos eso por ahora
  - prueba... quizás la demo de 🌌 🔫  ~Isostasy~ o 🐺 🌲  ~Wolf Spirit~
  responses:
  - ▶️  continuar [end]
