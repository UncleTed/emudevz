main:
  messages:
  - como ejemplo de <E/S mapeada en memoria>, ¡vamos a implementar el mando! 🎮
  - documenté cómo funciona
  - revisa 📄  ~/docs/controller.es.md~
  responses:
  - ¿así que por fin vamos a arreglar ese horrible bug del mando? [exercise]

exercise:
  messages:
  - sí 😅
  - 📚  crea una clase 🎮  `Controller`, usando 📄  ~/tmpl/Controller.js~ como plantilla
  - 📚  implementa `onRead()` y `onWrite(...)` siguiendo la documentación
  - |-
    BrokenNEEES instanciará y conectará tus mandos así:
      ```javascript const controller1 = new Controller(1);
      const controller2 = new Controller(2);
      controller1.other = controller2;
      controller2.other = controller1;```
  - 📚  como siempre, agrega la clase a 📄  ~/code/index.js~
  - 📚  ah, y mapea las lecturas/escrituras de $4016 y las lecturas de $4017 en 🐏  `CPUMemory`
  - |-
    por ejemplo, si la `address` es ```javascript 0x4016```, devuelve:
      ```javascript this.controllers[0].onRead()```
  responses:
  - (*) ¿por qué necesito referenciar al <otro> mando? [other]

other:
  messages:
  - ¡porque están conectados!
  - escribir un 1 en $4016 reinicia `cursor` en <ambos mandos>
  - y la bandera `strobe` solo existe en el mando del jugador 1
  - así que, si eres el jugador 2, necesitas usar la bandera `strobe` del otro mando
  responses:
  - ...exercise

corollary:
  messages:
  - bien, integremos tu 🎮  Mando en el emulador
  - dame un segundo...
  run-after-messages: |
    level.startEffect("earthquake");
    setTimeout(() => {
      bus.emit("patching-end");
    }, 1000);
  events: 
  - patching-end [done]

done:
  run: |
    level.stopEffect();
    book.unlock("useController");
  messages:
  - ✅  ¡listo!
  - <! 🎮  Mando integrado.
  - ahora, el ícono 🎮  en el emulador brillará ✨
  - y podrás presionar <A> y <Derecha> al mismo tiempo 😅
  responses:
  - ▶️  continuar [end]
