---
main:
  messages:
  - as an example of <memory-mapped I/O>, let's actually implement the controller! 🎮
  - I documented how it works!
  - check out 📄  ~/docs/controller.en.md~
  responses:
  - so we're finally fixing that awful controller bug? [exercise]

exercise:
  messages:
  - yeah 😅
  - 📚  create a 🎮  `Controller` class, using 📄  ~/tmpl/Controller.js~ as a template
  - 📚  implement `onRead()` and `onWrite(...)` following the documentation
  - |-
    BrokenNEEES will instantiate and connect your controllers like this:
      ```javascript const controller1 = new Controller(1);
      const controller2 = new Controller(2);
      controller1.other = controller2;
      controller2.other = controller1;```
  - 📚  as usual, add the class to 📄  ~/code/index.js~
  - 📚  ah, and map the $4016 read/writes and $4017 reads in 🐏  `CPUMemory`
  - |-
    for example, if the `address` is ```javascript 0x4016```, return:
      ```javascript this.controllers[0].onRead()```
  responses:
  - (*) why do I need to reference the <other> controller? [other]
  - (*) wait, explain the template 🤔 [template]
  - (*) I need help implementing `onRead(...)` [onread]
  - (*) I need help implementing `onWrite(...)` [onwrite]

other:
  messages:
  - because they are connected!
  - writing a 1 to $4016 resets `cursor` on <both controllers>
  - and the `strobe` flag only lives in player 1's controller
  - so, if you are player 2, you need to use the `strobe` flag from the other controller
  responses:
  - ...exercise

template:
  messages:
  - the proposed 🎮  `Controller` class sets up a `_buttons` array with booleans
  - this signals whether a button is <pressed> or <released>
  - the array is sorted following the sequence described in the documentation file
  - the `update(...)` method is gonna be called <automatically> by BrokenNEEES to update the state of each button
  - and games will <poll> addresses $4016 and $4017 (`onRead(...)` calls) to poll the current state
  responses:
  - how does the polling work? [poll]

poll:
  messages:
  - |-
    in a NEEES game, a typical procedure to read the inputs is:
      **->** write a 1 to $4016
      **->** write a 0 to $4016
      **->** (read $4016 and $4017) 8 times
  responses:
  - ...exercise

onread:
  messages:
  - |-
    **onRead()**:
      **->** stores the correct strobe value in a constant
        (that is, ```javascript this.strobe``` for <player 1> and ```javascript this.other.strobe``` for <player 2>)
        (let's call this `strobe`)

      **->** if the cursor is >= 8, returns 1

      **->** if `strobe`:
        **->** returns the state of the first button <as a number>
          (```javascript +boolean``` converts it to a number)
      **else:**
        **->** determines whether the current button is pressed (based on ```javascript this.cursor```)
          (let's call this `isPressed`)
        **->** increments ```javascript this.cursor```
        **->** returns ```javascript +isPressed```
  responses:
  - ...exercise

onwrite:
  messages:
  - |-
    **onWrite(value)**:
      **->** assigns <bit 0> of `value` (as a boolean) to ```javascript this.strobe```
        (you can use `byte.getFlag(...)` from 📄  ~/lib/byte.js~)

      **->** if `this.strobe`:
        **->** resets ```javascript this.cursor``` to 0
        **->** resets ```javascript this.other.cursor``` to 0
  responses:
  - ...exercise

corollary:
  messages:
  - alright, let's integrate your 🎮  Controller into the emulator
  - give me a second...
  run-after-messages: |
    level.startEffect("earthquake");
    setTimeout(() => {
      bus.emit("patching-end");
    }, 1000);
  events: 
  - patching-end [done]

done:
  run: |
    level.stopEffect();
    book.unlock("useController");
  messages:
  - ✅  done!
  - <! 🎮  Controller integrated.
  - now, the 🎮  icon in the emulator will glow ✨
  - and you'll be able to press <A> and <Right> at the same time 😅
  responses:
  - ▶️  continue [end]
