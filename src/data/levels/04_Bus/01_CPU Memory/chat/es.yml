---
main:
  messages:
  - repasemos rápidamente el esquema de memoria de la NEEES
  - la CPU tiene 2 KiB de RAM 🐏
  - pero las direcciones de memoria van de $0000 a $FFFF (~65535~)
  - por lo que el espacio direccionable completo es de 64 KiB
  responses:
  - si solo 2 KiB son RAM de verdad, ¿qué hay en los otros 62 KiB? 🤨 [other62]

other62:
  messages:
  - <{memory.png}>
  - otras cosas, como espejos de RAM, E/S mapeada en memoria y la información del cartucho
  - 🔗  ¡todo está conectado a la memoria!
  - así es como el código máquina interactúa con los dispositivos
  - el mapa de memoria tiene una estructura muy específica, mira 📄  ~/docs/cpu/cpu_memory.es.md~
  responses:
  - (*) ¿qué es "E/S mapeada en memoria"? 🗺️ [io]
  - 👌  ya veo... ¿qué necesito implementar? [exercise]

io:
  messages:
  - un esquema en el cual las direcciones de memoria están conectadas a dispositivos físicos
  - por ejemplo...
  - leer $4016 leerá los botones presionados del 🎮  mando
  - escribir los registros de la 🖥️  PPU en $2000-$2007 modificará la pantalla
  - escribir los registros de la 🔊  APU en $4000-$4013 producirá sonidos
  - leer $8000 probablemente leerá el primer byte de PRG-ROM del 💾  cartucho
  responses:
  - ...other62


exercise:
  messages:
  - por ahora, solo vamos a implementar el primer rango (🐏  WRAM)
  - 📚  crea una clase 🐏  `CPUMemory`, usando 📄  ~/tmpl/CPUMemory.js~ como plantilla
  - 📚  su constructor debería inicializar una propiedad `ram` (un `Uint8Array` de 2048 bytes)
  - |-
    📚  implementa el primer `// TODO` de cada método:
    **read(address)**:
      **->** si `address` está dentro del rango $0000-$07FF, retorna el byte correspondiente de `ram`
      **->** __deja el resto del código como está__
    **write(address, value)**:
      **->** si `address` está dentro del rango $0000-$07FF, escribe `value` al byte correspondiente de `ram` y retorna
      **->** __deja el resto del código como está__
  - 📚  luego, como hiciste con 💾  `Cartridge`, agrega la clase a 📄  ~/code/index.js~
  responses:
  - (*) ¿cómo es eso de los bytes espejados? 📐 [help]

help:
  messages:
  - manejé eso por ti, ya que esa parte puede ser un poco rebuscada
  - básicamente, llamar a ```javascript read(0x0802)``` debería retonar lo mismo que ```javascript read(0x0002)```
  - y llamar a ```javascript write(0x0802, value)``` debería tener el mismo efecto que tiene ```javascript write(0x0002, value)```
  - por eso es que el rango $0800-$1FFF es un 🚽  espejo de $0000-$07FF
  - "aquí dejo un ejemplo con el otro rango espejo en $2008:"
  - <{memory_mirror.png}>
  responses:
  - ...exercise
