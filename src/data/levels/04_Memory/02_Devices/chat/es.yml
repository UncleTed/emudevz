---
main:
  messages:
  - recuerda, cada componente de hardware tiene que estar conectado a la memoria
  - a medida que avances en tu desarrollo, tendrás que actualizar tu clase `CPUMemory`, agregando los mapeos correctos
  - un dispositivo importante que tenemos que agregar es el 🗜️  Mapper, el cual manejará todas las interacciones con el código de juego (🤖  PRG-ROM)
  - la 🧠  CPU accede al código solo leyendo bytes dentro de $4020-$FFFF
  - hagamos recibir a nuestra memoria un montón de <dispositivos> 📱
  - |-
    📚  agrega a tu `CPUMemory` el siguiente método:
    **onLoad(ppu, apu, mapper, controllers)**:
      **->** guarda los parámetros como propiedades (`this.ppu`, `this.apu`, `this.mapper`, y `this.controllers`)
  - 📚  luego, como hiciste antes con `this.ram`, modifica `read(...)` y `write(...)` para dejar que `this.mapper` maneje el rango $4020-$FFFF (💾  Espacio del cartucho)
  - en <lecturas>, deberías retornar `this.mapper.cpuRead(address)`
  - en <escrituras>, deberías llamar a `this.mapper.cpuWrite(address, value)` y retornar
  responses:
  - (*) ¿quién llama al método `onLoad`? 🤔 [who]
  - (*) ¿qué es un mapper? 🗜️ [mapper]

who:
  messages:
  - al cargar un juego, BrokenNEEES llamará a este método automáticamente ✨
  - para que la memoria tenga acceso al resto del hardware
  responses:
  - ...main

mapper:
  messages:
  - los mappers son circuitos dentro del cartucho que controlan cómo la consola lee la información del ROM
  - cada juego usa un mapper específico
  - mientras más mappers admita tu emulador, más juegos serán compatibles 👾
  - BrokenNEEES soporta los mappers más comunes (0-4)
  - sorprendentemente, ¡todos funcionan bien! 🤯  así que usarás esos por ahora
  - y aprenderás cómo agregar más en el capítulo de 🗜️  Mappers
  responses:
  - ...main
