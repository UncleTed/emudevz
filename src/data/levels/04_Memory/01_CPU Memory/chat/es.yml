---
main:
  messages:
  - repasemos rápidamente el esquema de memoria de la NEEES
  - la CPU tiene 2 KiB de RAM 🐏
  - pero las direcciones de memoria van de $0000 a $FFFF (65535)
  - por lo que el espacio direccionable completo es de 64 KiB
  responses:
  - si solo 2 KiB son RAM de verdad, ¿qué hay en los otros 62 KiB? 🤨 [other62]

other62:
  messages:
  - otras cosas, como espejos de RAM, E/S mapeada en memoria y la información del cartucho
  - 🔗  ¡todo está conectado a la memoria!
  - así es como el código máquina interactúa con los dispositivos
  - el mapa de memoria tiene una estructura muy específica, mira 📄  ~/docs/cpu/cpu_memory.es.md~
  responses:
  - (*) ¿qué es "E/S mapeada en memoria"? 🗺️ [io]
  - 👌  ya veo... ¿qué necesito implementar? [implement]

io:
  messages:
  - un esquema en el cual las direcciones de memoria están conectadas a dispositivos físicos
  - por ejemplo...
  - leer $4016 leerá los botones presionados del 🎮  mando
  - escribir los registros de la 🖥️  PPU en $2000-$2007 modificará la pantalla
  - escribir los registros de la 🔊  APU en $4000-$4013 producirá sonidos
  - leer $8000 probablemente leerá el primer byte de PRG-ROM del 💾  cartucho
  responses:
  - ...other62


implement:
  messages:
  - por ahora, solo vamos a implementar el primer rango (🐏  WRAM)
  - 📚  _-_crea una clase `CPUMemory`, usando _--_📄 _-_ ~/tmpl/CPUMemory.js~ como plantilla_--_
  - 📚  _-_su constructor debería inicializar una propiedad `ram` (un `Uint8Array` de 2048 bytes)_--_
  - |-
    📚  _-_implementa el primer ~TODO~ de cada método:_--_
    *_-_*read(address)**:_--_
      *_-_*->** si ~address~ está dentro del rango $0000-$07FF, retorna el byte correspondiente de ~ram~_--_
        _-_(deja el resto del código como está)_--_
    *_-_*write(address, value)**:_--_
      *_-_*->** si ~address~ está dentro del rango $0000-$07FF, escribe ~value~ al byte correspondiente de ~ram~ y retorna_--_
        _-_(deja el resto del código como está)_--_
  - 📚  _-_luego, como hiciste con `Cartridge`, agrega la clase a _--_📄 _-_ ~/code/index.js~_--_
  responses:
  - ¿cómo es eso de los bytes espejados? 📐 [help]

help:
  messages:
  - manejé eso por ti, ya que esa parte puede ser un poco rebuscada
  - básicamente, llamar a `read(0x0802)` debería retonar lo mismo que `read(0x0002)`
  - y llamar a `write(0x0802, value)` debería tener el mismo efecto que tiene `write(0x0002, value)`
  - por eso es que el rango $0800-$1FFF es 🚽  <un espejo> de $0000-$07FF
  - "aquí dejo un ejemplo con el otro rango espejo en $2008:"
  - <{memory_mirror.png}>
  responses: []
