---
main:
  messages:
  - let's implement a `step()` method that runs the next <operation>
  - it will read the next opcode and arguments from ðŸ¤–  PRG-ROM
  - call the right instruction and addressing mode
  - and increment the cycle counters
  responses:
  - you promised you'd explain cycles ðŸš² [cycles]
  - <<level.isCompleted || m.$exercise>> ðŸ“š  take me to the action [rightway]

cycles:
  messages:
  - and I will!
  - the time it takes for the CPU to execute an action is measured in cycles
  - cycles are very important if we want to build a "cycle-accurate" emulator (we don't!)
  - but they still matter to keep the different units (CPU, PPU, APU) on sync ðŸ”„
  - so every opcode knows how many cycles it should take
  responses:
  - (*) why don't we want to build a "cycle-accurate" emulator? [accuracy]
  - âœ…  alright, how should we proceed? [rightway]

accuracy:
  messages:
  - because it's a complex task ðŸ¥µ
  - and it can be especially challenging for individuals without prior experience in emulation
  - there are tricky-to-emulate games that demand accuracy in order to work
  - but most other games work just fine, so we won't need it anyway
  responses:
  - ...cycles

rightway:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - |-
    ðŸ“š  first, we'll add these methods to your `CPU`:
    **_fetchOperation()**:
      **->** reads a byte from the memory address that [PC] points at
        (let's call this `opcode`)
      **->** finds the operation related with that opcode:
        `this.operations[opcode]`
        (let's call this `operation`)
      **->** if `operation` doesn't exist, throws an "Invalid opcode." error
      **->** increments [PC]
      **->** returns `operation`
    **_fetchInput(operation)**:
      **->** reads 0, 1 (using `read(...)`) or 2 bytes (using `read16(...)`) from the memory address that [PC] points at, depending on `operation.addressingMode.inputSize`
        (let's call this `input`)
      **->** increments [PC] (0, 1, or 2 times) to skip those bytes
      **->** returns `input` (or `null`)
    **_fetchArgument(operation, input)**:
      **->** returns the result of processing `input` with the addressing mode
        - if `operation.instruction.argument === "value"`, it should be:
            `operation.addressingMode.getValue(this, input, operation.hasPageCrossPenalty)`
        - else:
            `operation.addressingMode.getAddress(this, input, operation.hasPageCrossPenalty)`
    **_addCycles(operation)**:
      **->** calculates how many cycles the `operation` took:
        `operation.cycles + this.extraCycles`
        (let's call this `cycles`)
      **->** updates the cycle counters:
        `this.cycle += cycles;`
        `this.extraCycles = 0;`
      **->** returns `cycles`
  responses:
  - what about the `step()` method you mentioned? [step]

step:
  messages:
  - |-
    ðŸ“š  our `step()` method should come up easily, using the others:
      ```javascript step() {
        const originalPC = this.pc.getValue();
        
        const operation = this._fetchOperation();
        const input = this._fetchInput(operation);
        const argument = this._fetchArgument(operation, input);

        if (this.logger != null) {
          this.logger(
            this,
            originalPC,
            operation,
            input,
            argument
          )
        }
        
        operation.instruction.run(this, argument);
        return this._addCycles(operation);
      }```
  responses: []
