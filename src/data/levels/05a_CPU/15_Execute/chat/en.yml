---
main:
  messages:
  - let's implement our `step(...)` method The Right Way‚Ñ¢Ô∏è
  - here, we'll read the correct arguments from ü§ñ  <PRG-ROM>
  - call the right <instruction> and <addressing mode>
  - and increment the cycle counters
  responses:
  - you promised you'd explain cycles üö≤ [cycles]
  - <m.$exercise> üìö  take me to the exercise [rightway]

cycles:
  messages:
  - and I will!
  - the time it takes for the CPU to execute an action is measured in <cycles>
  - cycles are very important if we want to build a "cycle-accurate" emulator (we don't!)
  - but they still matter to keep the different units (CPU, PPU, APU) on sync üîÑ
  - so every opcode knows how many cycles it should take
  responses:
  - (*) why don't we want to build a "cycle-accurate" emulator? [accuracy]
  - ‚úîÔ∏è  alright, what's The Right Way‚Ñ¢Ô∏è? [rightway]

accuracy:
  messages:
  - because it's a complex task ü•µ
  - and it can be especially challenging for individuals without prior experience in emulation
  - there are tricky-to-emulate games that demand accuracy in order to work
  - but most other games work just fine, so we won't need it anyway
  responses:
  - ...cycles

rightway:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - |-
    üìö  we'll add this method to your `CPU`:
    **step()**:
      __-> remember the original value of PC
        (let's call this <originalPC>)

      -> read a byte from the memory location that PC points at
        (let's call this <opcode>)
      -> find the operation related with that opcode: this.operations[opcode]
        (let's call this <operation>)
      -> if <operation> doesn't exist, throw an "Invalid opcode." error
      -> increment PC

      -> read 0, 1 (using read) or 2 bytes (using read16) from the memory location that PC points at, depending on operation.addressingMode.inputSize
        (let's call this <input>)
      -> increment PC (0, 1, or 2 times) to skip those bytes

      -> if operation.instruction.argument === "value", call operation.addressingMode.getValue(this, input, operation.hasPageCrossPenalty)
         else, instead of getValue, call getAddress (with the same arguments)
        (let's call the resulting value <argument>)

      -> if this.logger != null, call this.logger(...) with:
        1. the CPU instance (this)
        2. <originalPC>
        3. <operation>
        4. <input> (or null)
        5. <argument> (or null)
        (we'll use this later)

      -> call operation.instruction.run(this, argument)
      -> calculate how many cycles it took (operation.cycles + this.extraCycles)
        (let's call this <cycles>)
      -> update the cycle counters:
        this.cycle += cycles;
        this.extraCycles = 0;

      -> return <cycles>__
  responses: []
