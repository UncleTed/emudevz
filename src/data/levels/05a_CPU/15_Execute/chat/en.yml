---
main:
  messages:
  - let's implement a `step()` method that runs the next operation
  - it will read the next opcode and arguments from 🤖  <PRG-ROM>
  - call the right <instruction> and <addressing mode>
  - and increment the cycle counters
  responses:
  - you promised you'd explain cycles 🚲 [cycles]
  - <<level.isCompleted || m.$exercise>> 📚  take me to the action [rightway]

cycles:
  messages:
  - and I will!
  - the time it takes for the CPU to execute an action is measured in <cycles>
  - cycles are very important if we want to build a "cycle-accurate" emulator (we don't!)
  - but they still matter to keep the different units (CPU, PPU, APU) on sync 🔄
  - so every opcode knows how many cycles it should take
  responses:
  - (*) why don't we want to build a "cycle-accurate" emulator? [accuracy]
  - ✔️  alright, how should we proceed? [rightway]

accuracy:
  messages:
  - because it's a complex task 🥵
  - and it can be especially challenging for individuals without prior experience in emulation
  - there are tricky-to-emulate games that demand accuracy in order to work
  - but most other games work just fine, so we won't need it anyway
  responses:
  - ...cycles

rightway:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - |-
    📚  _-_first, we'll add these helper methods to your `CPU`:_--_
    **_fetchOperation()**:
      __-> read a byte from the memory location that PC points at
        (let's call this <opcode>)
      -> find the operation related with that opcode: this.operations[opcode]
        (let's call this <operation>)
      -> if <operation> doesn't exist, throw an "Invalid opcode." error
      -> increment PC
      -> return <operation>__
    **_fetchInput(operation)**:
      __-> read 0, 1 (using read) or 2 bytes (using read16) from the memory location that PC points at, depending on operation.addressingMode.inputSize
        (let's call this <input>)
      -> increment PC (0, 1, or 2 times) to skip those bytes
      -> return <input>__
    **_fetchArgument(operation, input)**:
      __-> return the result of processing the <input> with the addressing mode
      -> if operation.instruction.argument === "value", it should be:
        operation.addressingMode.getValue(this, input, operation.hasPageCrossPenalty)
      -> else:
        operation.addressingMode.getAddress(this, input, operation.hasPageCrossPenalty)__
    **_addCycles(operation)**:
      __-> calculate how many cycles the <operation> took (operation.cycles + this.extraCycles)
        (let's call this <cycles>)
      -> update the cycle counters:
        this.cycle += cycles;
        this.extraCycles = 0;
      -> return <cycles>__
  responses:
  - what about the `step()` method you mentioned? [step]

step:
  messages:
  - |-
    // TODO: TRADUCIR
    _-_our `step()` method should come up easily, using the others:
      ```javascript step() {
        const originalPC = this.pc.getValue();
        
        const operation = this._fetchOperation();
        const input = this._fetchInput(operation);
        const argument = this._fetchArgument(operation, input);

        if (this.logger != null) {
          this.logger(
            this,
            originalPC,
            operation,
            input,
            argument
          )
        }
        
        operation.instruction.run(this, argument);
        return this._addCycles(operation);
      }```_--_
  responses: []
