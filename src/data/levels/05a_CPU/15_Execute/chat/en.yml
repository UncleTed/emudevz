---
main:
  messages:
  - let's implement a `step()` method that runs the next <operation>
  - it will read the next opcode and arguments from 🤖  <PRG-ROM>
  - call the right <instruction> and <addressing mode>
  - and increment the cycle counters
  responses:
  - you promised you'd explain cycles 🚲 [cycles]
  - <<level.isCompleted || m.$exercise>> 📚  take me to the action [rightway]

cycles:
  messages:
  - and I will!
  - the time it takes for the CPU to execute an action is measured in <cycles>
  - cycles are very important if we want to build a "cycle-accurate" emulator (we don't!)
  - but they still matter to keep the different units (CPU, PPU, APU) on sync 🔄
  - so every opcode knows how many cycles it should take
  responses:
  - (*) why don't we want to build a "cycle-accurate" emulator? [accuracy]
  - ✔️  alright, how should we proceed? [rightway]

accuracy:
  messages:
  - because it's a complex task 🥵
  - and it can be especially challenging for individuals without prior experience in emulation
  - there are tricky-to-emulate games that demand accuracy in order to work
  - but most other games work just fine, so we won't need it anyway
  responses:
  - ...cycles

rightway:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - |-
    📚  _-_first, we'll add these methods to your `CPU`:_--_
    *_-_*_fetchOperation()**:_--_
      *_-_*->** reads a byte from the memory location that [PC] points at_--_
        _-_(let's call this ~opcode~)_--_
      *_-_*->** finds the operation related with that opcode:_--_
        _-_~this.operations[opcode]~_--_
        _-_(let's call this ~operation~)_--_
      *_-_*->** if ~operation~ doesn't exist, throws an "Invalid opcode." error_--_
      *_-_*->** increments [PC]_--_
      *_-_*->** returns ~operation~_--_
    *_-_*_fetchInput(operation)**:_--_
      *_-_*->** reads 0, 1 (using ~read(...)~) or 2 bytes (using ~read16(...)~) from the memory location that [PC] points at, depending on ~operation.addressingMode.inputSize~_--_
        _-_(let's call this ~input~)_--_
      *_-_*->** increments [PC] (0, 1, or 2 times) to skip those bytes_--_
      *_-_*->** returns ~input~ (or ~null~)_--_
    *_-_*_fetchArgument(operation, input)**:_--_
      *_-_*->** returns the result of processing ~input~ with the addressing mode_--_
        _-_- if ~operation.instruction.argument === "value"~, it should be:_--_
            _-_~operation.addressingMode.getValue(this, input, operation.hasPageCrossPenalty)~_--_
        _-_- else:_--_
            _-_~operation.addressingMode.getAddress(this, input, operation.hasPageCrossPenalty)~_--_
    *_-_*_addCycles(operation)**:_--_
      *_-_*->** calculates how many cycles the ~operation~ took:_--_
        _-_~operation.cycles + this.extraCycles~_--_
        _-_(let's call this ~cycles~)_--_
      *_-_*->** updates the cycle counters:_--_
        _-_~this.cycle += cycles;~_--_
        _-_~this.extraCycles = 0;~_--_
      *_-_*->** returns ~cycles~_--_
  responses:
  - what about the `step()` method you mentioned? [step]

step:
  messages:
  - |-
    📚  _-_our `step()` method should come up easily, using the others:
      ```javascript step() {
        const originalPC = this.pc.getValue();
        
        const operation = this._fetchOperation();
        const input = this._fetchInput(operation);
        const argument = this._fetchArgument(operation, input);

        if (this.logger != null) {
          this.logger(
            this,
            originalPC,
            operation,
            input,
            argument
          )
        }
        
        operation.instruction.run(this, argument);
        return this._addCycles(operation);
      }```_--_
  responses: []
