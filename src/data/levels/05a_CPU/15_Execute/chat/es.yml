---
main:
  messages:
  - implementemos un m√©todo `step(...)` que ejecute la siguiente operaci√≥n
  - leer√° el siguiente opcode y argumentos desde ü§ñ  <PRG-ROM>
  - llamar√° a la <instrucci√≥n> correcta y al <modo de direccionamiento> adecuado
  - e incrementar√° los contadores de ciclos
  responses:
  - prometiste que explicar√≠as ciclos üö≤ [cycles]
  - <<level.isCompleted || m.$exercise>> üìö  ll√©vame a la acci√≥n [rightway]

cycles:
  messages:
  - ¬°y lo har√©!
  - el tiempo que le toma a la CPU ejecutar una acci√≥n se mide en <ciclos>
  - los ciclos son muy importantes si queremos construir un emulador "cycle-accurate" (¬°no queremos!)
  - pero igualmente sirven para mantener las diferentes unidades (CPU, PPU, APU) en sincron√≠a üîÑ
  - por lo que cada opcode sabe cu√°ntos ciclos deber√≠a tomar
  responses:
  - (*) ¬øpor qu√© no queremos construir un emulador "cycle-accurate"? [accuracy]
  - ‚úîÔ∏è  bueno, ¬øc√≥mo hacemos? [rightway]

accuracy:
  messages:
  - porque es una tarea compleja ü•µ
  - y puede ser especialmente complicada para gente sin conocimientos previos en emulaci√≥n
  - existen juegos "dif√≠ciles de emular" que demandan precisi√≥n para funcionar
  - pero la mayor√≠a de los otros simplemente funciona bien, as√≠ que no lo necesitaremos de todas formas
  responses:
  - ...cycles

rightway:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - |-
    üìö  _-_vamos a agregar este m√©todo en tu `CPU`:_--_
    **step()**:
      __-> recuerda el valor original de PC
        (llamemos esto <originalPC>)

      -> lee un byte de la ubicaci√≥n de memoria apuntada por PC
        (llamemos esto <opcode>)
      -> encuentra la operaci√≥n relacionada con ese opcode: this.operations[opcode]
        (llamemos esto <operation>)
      -> si <operation> no existe, tira un error "Invalid opcode."
      -> incrementa PC

      -> lee 0, 1 (usando read) o 2 bytes (usando read16) de la ubicaci√≥n de memoria apuntada por PC, dependiendo de operation.addressingMode.inputSize
        (llamemos esto <input>)
      -> incrementa PC (0, 1, o 2 veces) para saltear esos bytes

      -> si operation.instruction.argument === "value", llama a operation.addressingMode.getValue(this, input, operation.hasPageCrossPenalty)
         si no, en vez de a getValue, llama a getAddress (con los mismos argumentos)
        (llamemos al valor resultante <argument>)

      -> si this.logger != null, llama a this.logger(...) con:
        1. la instancia de la CPU (this)
        2. <originalPC>
        3. <operation>
        4. <input> (o null)
        5. <argument> (o null)
        (vamos a usar esto despu√©s)

      -> llama a operation.instruction.run(this, argument)
      -> calcula cu√°ntos ciclos tom√≥ (operation.cycles + this.extraCycles)
        (llamemos esto <cycles>)
      -> actualiza los contadores de ciclos:
        this.cycle += cycles;
        this.extraCycles = 0;

      -> retorna <cycles>__
  responses: []
