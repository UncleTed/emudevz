---
main:
  messages:
  - implementemos un método `step()` que ejecute la siguiente <operación>
  - leerá el siguiente opcode y argumentos desde 🤖  <PRG-ROM>
  - llamará a la <instrucción> correcta y al <modo de direccionamiento> adecuado
  - e incrementará los contadores de ciclos
  responses:
  - prometiste que explicarías ciclos 🚲 [cycles]
  - <<level.isCompleted || m.$exercise>> 📚  llévame a la acción [rightway]

cycles:
  messages:
  - ¡y lo haré!
  - el tiempo que le toma a la CPU ejecutar una acción se mide en <ciclos>
  - los ciclos son muy importantes si queremos construir un emulador "cycle-accurate" (¡no queremos!)
  - pero igualmente sirven para mantener las diferentes unidades (CPU, PPU, APU) en sincronía 🔄
  - por lo que cada opcode sabe cuántos ciclos debería tomar
  responses:
  - (*) ¿por qué no queremos construir un emulador "cycle-accurate"? [accuracy]
  - ✔️  bueno, ¿cómo hacemos? [rightway]

accuracy:
  messages:
  - porque es una tarea compleja 🥵
  - y puede ser especialmente complicada para gente sin conocimientos previos en emulación
  - existen juegos "difíciles de emular" que demandan precisión para funcionar
  - pero la mayoría de los otros simplemente funciona bien, así que no lo necesitaremos de todas formas
  responses:
  - ...cycles

rightway:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - |-
    📚  _-_primero, vamos a agregar estos métodos a tu `CPU`:_--_
    *_-_*_fetchOperation()**:_--_
      *_-_*->** lee un byte de la ubicación de memoria apuntada por [PC]_--_
        _-_(llamemos a esto ~opcode~)_--_
      *_-_*->** encuentra la operación relacionada con ese opcode:_--_
        _-_~this.operations[opcode]~_--_
        _-_(llamemos a esto ~operation~)_--_
      *_-_*->** si ~operation~ no existe, tira un error "Invalid opcode."_--_
      *_-_*->** incrementa [PC]_--_
      *_-_*->** retorna ~operation~_--_
    *_-_*_fetchInput(operation)**:_--_
      *_-_*->** lee 0, 1 (usando ~read(...)~) o 2 bytes (usando ~read16(...)~) de la ubicación de memoria apuntada por [PC], dependiendo de ~operation.addressingMode.inputSize~_--_
        _-_(llamemos a esto ~input~)_--_
      *_-_*->** incrementa [PC] (0, 1, o 2 veces) para saltear esos bytes_--_
      *_-_*->** retorna ~input~ (o ~null~)_--_
    *_-_*_fetchArgument(operation, input)**:_--_
      *_-_*->** retorna el resultado de procesar ~input~ con el modo de direccionamiento_--_
        _-_- si ~operation.instruction.argument === "value"~, debería ser:_--_
            _-_~operation.addressingMode.getValue(this, input, operation.hasPageCrossPenalty)~_--_
        _-_- si no:_--_
            _-_~operation.addressingMode.getAddress(this, input, operation.hasPageCrossPenalty)~_--_
    *_-_*_addCycles(operation)**:_--_
      *_-_*->** calcula cuántos ciclos tomó la ~operation~:_--_
        _-_~operation.cycles + this.extraCycles~_--_
        _-_(llamemos a esto ~cycles~)_--_
      *_-_*->** actualiza los contadores de ciclos:_--_
        _-_~this.cycle += cycles;~_--_
        _-_~this.extraCycles = 0;~_--_
      *_-_*->** retorna ~cycles~_--_
  responses:
  - ¿y el método `step()` que mencionaste? [step]

step:
  messages:
  - |-
    _-_nuestro método `step()` debería salir fácil, usando los otros:
      ```javascript step() {
        const originalPC = this.pc.getValue();
        
        const operation = this._fetchOperation();
        const input = this._fetchInput(operation);
        const argument = this._fetchArgument(operation, input);

        if (this.logger != null) {
          this.logger(
            this,
            originalPC,
            operation,
            input,
            argument
          )
        }
        
        operation.instruction.run(this, argument);
        return this._addCycles(operation);
      }```_--_
  responses: []
