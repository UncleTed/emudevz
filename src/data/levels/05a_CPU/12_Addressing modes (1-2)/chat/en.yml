---
main:
  messages:
  - remember the <addressing modes> from the assembly chapter?
  - <{compilation_full.png}>
  - well... it's time to emulate them 😏
  - I made a quick reference for you
  - check out 📄  ~/docs/cpu/addressing_modes.en.md~
  responses:
  - I'll definitely need you to explain this a bit further [explain]

explain:
  messages:
  - yeah
  - you can see every addressing mode has an <input> and an <output>
  - ⬅️  the <input> is the operation's argument (what follows the opcode, remember?)
  - in `JMP ($4080)` the <input> would be $4080
  - ➡️  the <output> is what the instructions end up actually receiving
  - (the `address` argument in your `JMP` instruction's `run(...)` function)
  - in this case, the <output> would be the result of performing a 16-bit read to address $4080
  responses:
  - ✅  ok, let's code this [letscode]

letscode:
  messages:
  - actually I already coded some of these modes
  - so you'll only have to implement "Relative" and "Indirect"
  - you can grab the code from 📄  ~/tmpl/cpu/addressingModes.js~ and continue from there!
  - 📚  _-_implement the missing addressing modes_--_
  - 📚  _-_and export the object under the `addressingModes` key in _--_📄 _-_ ~/code/index.js~_--_
  responses:
  - help me with the "Relative" mode 😅 [relative]
  - help me with the "Indirect" mode 😅 [indirect]

relative:
  messages:
  - 💡  remember that it takes an "offset" (a signed byte)
  - signed bytes can be tricky to understand for humans
  - they use the "Two's component" notation, which is explained briefly in 📄  ~/lib/byte.js~
  - for example, if the offset is ~-3~, you would receive a 253
  - you can convert that 253 to ~-3~ using the `toS8` method
  - 💡  also, to check for page crossing events, you will need `highByteOf(...)`
  responses:
  - ...letscode

indirect:
  messages:
  - you have a full implementation in the doc file 😊
  - just perform a `read16` with the address!
  responses:
  - ...letscode
