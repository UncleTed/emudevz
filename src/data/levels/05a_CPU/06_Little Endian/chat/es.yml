---
main:
  messages:
  - a veces, los valores se representan usando más de 1 byte
  - p. ej. cuando una instrucción de CPU tiene una dirección de 16 bits como argumento
  - o al usar la instrucción `RTS` y la CPU tiene que restaurar [PC] desde la pila
  - en estos casos, se usa la convención <Little Endian> 🔌
  - "eso quiere decir: el byte menos significativo (\"low byte\") se guarda primero, luego el más significativo (\"high byte\")"
  - <{little_endian.png}>
  - |-
    📚  _-_implementa este método en `CPUMemory`:_--_
    *_-_*read16(address)**:_--_
      *_-_*->** retorna un número de 16 bits_--_
        _-_- el "low byte" se obtiene leyendo ~address~ de la memoria_--_
        _-_- el "high byte" se obtiene leyendo ~address+1~_--_
  - |-
    📚  _-_y estos dos métodos en `Stack`:_--_
    *_-_*push16(bigNumber)**:_--_
      *_-_*->** llama a ~push(...)~ dos veces (primero con el "high byte" de ~bigNumber~, luego con su "low byte")_--_
    *_-_*pop16()**:_--_
      *_-_*->** retorna un número de 16 bits como resultado de hacer ~pop()~ dos veces (primero el "low byte", luego el "high byte")_--_
  - 💡  _-_¡recuerda usar _--_📄 _-_ ~/lib/byte.js~!_--_
  responses: []
