---
main:
  messages:
  - sometimes, values are represented using more than 1 byte
  - e.g. when a CPU instruction has a 16-bit address as an argument
  - or when using the `RTS` instruction and the CPU needs to restore [PC] from the stack
  - in these cases, the Little Endian convention is used 🔌
  - "that means: the least significant byte (\"low byte\") is stored first, then the most significant byte (\"high byte\")"
  - <{little_endian.png}>
  - |-
    📚  implement this method in 🐏  `CPUMemory`:
    **read16(address)**:
      **->** returns a 16-bit number
        - the low byte is obtained by reading `address` from memory
        - the high byte is obtained by reading ```javascript address+1```
  - |-
    📚  and these two methods in 🧱  `Stack`:
    **push16(bigNumber)**:
      **->** calls `push(...)` twice (first with the high byte of `bigNumber`, then with its low byte)
    **pop16()**:
      **->** returns a 16-bit number as a result of calling `pop()` two times (first the low byte, then the high one)
  - 💡  remember to use 📄  ~/lib/byte.js~!
  responses: []
