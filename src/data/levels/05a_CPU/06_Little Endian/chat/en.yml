---
main:
  messages:
  - sometimes, values are represented using more than 1 byte
  - e.g. when a CPU instruction has a 16-bit address as an argument
  - or when using the `RTS` instruction and the CPU needs to restore [PC] from the stack
  - in these cases, the <Little Endian> convention is used ğŸ”Œ
  - "that means: the least significant byte (\"low byte\") is stored first, then the most significant byte (\"high byte\")"
  - <{little_endian.png}>
  - |-
    ğŸ“š  _-_implement this method in `CPUMemory`:_--_
    *_-_*read16(address)**:_--_
      *_-_*->** returns a 16-bit number_--_
        _-_- the low byte is obtained by reading ~address~ from memory_--_
        _-_- the high byte is obtained by reading ~address+1~_--_
  - |-
    ğŸ“š  _-_and these two methods in `Stack`:_--_
    *_-_*push16(bigNumber)**:_--_
      *_-_*->** calls ~push(...)~ twice (first with the high byte of ~bigNumber~, then with its low byte)_--_
    *_-_*pop16()**:_--_
      *_-_*->** returns a 16-bit number as a result of calling ~pop()~ two times (first the low byte, then the high one)_--_
  - ğŸ’¡  _-_remember to use _--_ğŸ“„ _-_ ~/lib/byte.js~!_--_
  responses: []
