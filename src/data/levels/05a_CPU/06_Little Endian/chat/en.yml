---
main:
  messages:
  - sometimes, values are represented using more than 1 byte
  - e.g. when a CPU instruction has a 16-bit address as an argument
  - or when using the `RTS` instruction and the CPU needs to restore [PC] from the stack
  - in these cases, the <Little Endian> convention is used ğŸ”Œ
  - "that means: the least significant byte (\"low byte\") is stored first, then the most significant byte (\"high byte\")"
  - |-
    ğŸ“š  implement this method in `CPUMemory`:
    **read16(address)**:
      __-> returns a 16-bit number
        - the low byte is obtained by reading <address> from memory
        - the high byte is obtained by reading <address>+1__
  - |-
    and these two methods in `Stack`:
    **push16(bigNumber)**:
      __-> *pushes* the high byte of <bigNumber> first, then *pushes* its low byte__
    **pop16()**:
      __-> returns a 16-bit number as a result of *popping* from the stack two times (first the low byte, then the high one)__
  - ğŸ’¡  remember to use ğŸ“„  ~/lib/byte.js~!
  responses: []
