---
main:
  messages:
  - solo quedan dos instrucciones 🎉
  - "y una de ellas es bastante trivial: `NOP`"
  - "`NOP` significa \"No Operation\", ¡y no hace nada!"
  - los desarrolladores de juegos usaban esto como un espacio reservado, o para introducir retrasos de tiempo para sincronizar sus sistemas
  - así que, la última es `BRK`, que genera un <Pedido de Interrupción>
  responses:
  - ¿qué es una interrupción? [interrupt]
  - <<level.isCompleted || m.$exercise>> 📚  llévame a la acción [implement]

interrupt:
  messages:
  - es una señal que interrumpe el programa actual para manejar un evento específico
  - cuando tal evento ocurre, la CPU guarda su estado ([PC] y registro de banderas) en la pila
  - y salta a una dirección de memoria conocida (llamada "vector") asociada a ese evento
  - "en la NEEES, hay 3 eventos:"
  - "🔁  <RESET>: Disparado cuando el sistema se enciende"
  - "📹  <NMI>: Disparado cuando la PPU termina de dibujar un frame"
  - "✋  <IRQ>: Disparado por una instrucción `BRK`, la APU, o hardware externo como mappers"
  responses:
  - ¿puedes darme un ejemplo? 🤔 [example]

example:
  messages:
  - ¡sí! imagina que eres un juego
  - necesitas mover tus sprites cuando la PPU termina de renderizar su frame actual, para evitar hacerlo mientras está dibujando (causando glitches 💥 )
  - así que, pones tu código que mueve sprites en -por ejemplo- la dirección $90CC
  - esa será la ubicación de tu <manejador de interrupciones>
  - y luego te "suscribes" al evento <NMI> poniendo un puntero a $90CC en el vector de <NMI> (que es ~$FFFA/B~)
  - (en Little Endian, por lo que $FFFA guarda $CC y $FFFB guarda $90)
  responses:
  - ¿qué pasaría cuando un <NMI> ocurre? [nmi]

nmi:
  messages:
  - "en este ejemplo, cuando un <NMI> es disparado, la CPU:"
  - 🧱  pone [PC] y las banderas en la pila
  - 🏁  asigna ~I=1~, que desactiva las interrupciones del usuario
  - 🐏  toma el valor $90CC de leer $FFFA y $FFFB (el vector de <NMI>)
  - 🦘  salta a $90CC
  - 🚲  consume 7 ciclos haciendo todo esto
  - luego, el manejador de interrupciones moverá los sprites y ejecutará `RTI` ("Return from Interrupt") para restaurar el estado anterior
  responses:
  - (*) ¿qué es eso de los 7 ciclos? 🚲 [cycle]
  - (*) ¿cuál es el propósito de la bandera ~I~? 🏁 [iflag]
  - ¡genial! creo que ya podría implementarlo 😎 [implement]

cycle:
  messages:
  - es el tiempo que toma procesar una interrupción 🕖
  - no hablamos mucho de ciclos hasta ahora
  - solo te hice agregar unas propiedades misteriosas en la clase `CPU`, ¿recuerdas?
  - esas llamadas `cycles` y `extraCycles`
  - voy a explicar más esto luego, lo prometo 😅
  responses:
  - ...nmi

iflag:
  messages:
  - es la bandera "Interrupt Disable", y como su nombre indica, desactiva las interrupciones
  - el sistema asigna ~I=1~ para que los manejadores de interrupciones no sean... mmm... interrumpidos 😅
  - |-
    la cosa es que... solo los eventos <IRQ> se pueden desactivar
    <RESET> no puede ser ignorada por obvias razones
    <NMI> quiere decir "Non-maskable interrupt" y es muy importante, por lo que no puede ser "masked" (o sea, desactivada)
  responses:
  - ...nmi

implement:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - genial
  - vamos a modelar las interrupciones como objetos `{ id, vector }`
  - revisa 📄  ~/lib/interrupts.js~
  - |-
    📚  _-_agrega este método a tu `CPU`:_--_
    *_-_*interrupt(interrupt, withBFlag = false)**:_--_
      *_-_*->** si ~interrupt.id === "IRQ"~ y ~I=1~, retorna 0_--_
        _-_(la interrupción es ignorada)_--_
      *_-_*->** pone [PC] en la pila_--_
      *_-_*->** pone el byte de banderas en la pila_--_
        _-_(si ~withBFlag~ es ~true~, el valor se agrega a la pila con el bit 4 encendido)_--_
        _-_(de lo contrario, se agrega tal cual está)_--_
      *_-_*->** avanza 7 ciclos (~this.cycle += 7~)_--_
      *_-_*->** asigna ~I=1~ en el registro de banderas_--_
      *_-_*->** asigna [PC] = al resultado de leer las direcciones ~interrupt.vector~ y ~interrupt.vector+1~ en <Little Endian>_--_
        _-_(recuerda que tienes un método ~read16(...)~ para eso)_--_
      *_-_*->** retorna 7_--_
  responses:
  - ¿y ~BRK~? [brk]

brk:
  messages:
  - |-
    📚  _-_puedes implementar la instrucción `BRK` solo llamando
      ```javascript cpu.interrupt(interrupts.IRQ, true)```_--_
  responses: []
