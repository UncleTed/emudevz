---
main:
  messages:
  - implementemos el m√©todo `step(...)` de La Forma Correcta‚Ñ¢Ô∏è
  - aqu√≠, leeremos los argumentos correctos desde <PRG-ROM>
  - llamaremos a la <instrucci√≥n> correcta y al <modo de direccionamiento> adecuado
  - e incrementaremos los contadores de ciclos
  responses:
  - prometiste que explicar√≠as ciclos üö≤ [cycles]

cycles:
  messages:
  - ¬°y lo har√©!
  - el tiempo que le toma a la CPU ejecutar una acci√≥n se mide en <ciclos>
  - los ciclos son muy importantes si queremos construir un emulador "cycle-accurate" (¬°no queremos!)
  - pero igualmente sirven para mantener las diferentes unidades (CPU, PPU, APU) en sincron√≠a üîÑ
  - por lo que cada opcode sabe cu√°ntos ciclos deber√≠a tomar
  responses:
  - (*) ¬øpor qu√© no queremos construir un emulador "cycle-accurate"? [accuracy]
  - bueno, ¬øy cu√°l es La Forma Correcta‚Ñ¢Ô∏è? [rightway]

accuracy:
  messages:
  - porque es una tarea compleja ü•µ
  - y MUY compleja para gente sin conocimientos previos en emulaci√≥n
  - existen juegos "dif√≠ciles de emular" que demandan precisi√≥n para funcionar
  - pero la mayor√≠a de los otros simplemente funciona bien, as√≠ que no lo necesitaremos de todas formas
  responses:
  - ...cycles

rightway:
  messages:
  - |-
    üìö  vamos a reescribir este m√©todo en tu `CPU`:
    **step()**:
      __-> lee un byte de la ubicaci√≥n de memoria apuntada por PC
        (llamemos esto <opcode>)
      -> encuentra la operaci√≥n relacionada con ese opcode: this.operations[opcode]
        (llamemos esto <operation>)
      -> si <operation> es null, tira un error "Unknown opcode."
      -> incrementa PC
      -> lee 0, 1 (usando read) o 2 bytes (usando read16) dependiendo de operation.addressingMode.inputSize
        (llamemos esto <input>)
      -> incrementa PC (0, 1, o 2 veces) para saltear esos bytes
      -> si opcode.instruction.argument === "value", llama a opcode.addressing.getValue(this, input, opcode.hasPageCrossPenalty)
         si no, llama a opcode.addressing.getAddress(this, input, opcode.hasPageCrossPenalty)
        (llamemos al valor resultante <argument>)
      -> si this.logger != null, llama a this.logger(...) con:
        1. la instancia de la CPU (this)
        2. el valor de PC (this.pc.getValue())
        3. <operation>
        4. <input>
        5. <argument>
        (vamos a usar esto despu√©s)
      -> llama a operation.instruction.run(this, argument)
      -> calcula cu√°ntos ciclos tom√≥ (operation.cycles + this.extraCycles)
        (llamemos esto <cycles>)
      -> (incrementa / reinicia) los contadores de ciclos:
        this.cycle += cycles;
        this.extraCycles = 0;
      -> retorna <cycles>__
  responses: []
