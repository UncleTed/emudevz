---
main:
  messages:
  - "📚  vas a empezar creando dos clases: `Register8Bit` y `Register16Bit` 🔢"
  - |-
    tendrían que tener dos métodos:
    **getValue()**:
      __-> retorna el contenido del registro__
    **setValue(value)**:
      __-> asigna el contenido del registro__
  - el contenido del registro comienza en 0 y puede ser un número de 8 bits (0-255) o uno de 16 bits (0-65535), dependiendo de la clase
  responses:
  - (*) ¿y si trato de escribir fuera de los límites? 🚫 [limit]
  - (*) ¿cuál es la mejor manera de implementar esto? 🤔 [implement]
  - ✔️  ya creé las clases, ¿ahora qué? [nowwhat]

limit:
  messages:
  - da la vuelta 🔄 , y el valor resultante siempre termina quedando dentro del rango válido
  - |-
    aquí, algunos ejemplos:
    ```raw ___________________________
    |  Type  | Write | Result |
    |--------|-------|--------|
    | 8-bit  | 258   | 2      |
    | 8-bit  | 518   | 6      |
    | 8-bit  | -2    | 254    |
    | 8-bit  | -128  | 128    |
    | 8-bit  | -200  | 56     |
    | 16-bit | 65536 | 0      |
     ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾```
  responses:
  - ...main

implement:
  messages:
  - yo crearía arrays tipados que contengan solo un elemento, como ```javascript new Uint8Array(1)``` y ```javascript new Uint16Array(1)```
  - luego, cuando hagas algo como ```javascript array[0] = 258;```, el valor se ajustará automáticamente ✨
  responses:
  - ...main

nowwhat:
  messages:
  - |-
    entonces, agrega el siguiente constructor a tu clase `CPU`:
    ```javascript
    export default class CPU {
      constructor() {
        this.cycle = 0;
        this.extraCycles = 0;

        this.a = new Register8Bit();
        this.x = new Register8Bit();
        this.y = new Register8Bit();
        this.sp = new Register8Bit();
        this.pc = new Register16Bit();
      }
    }```
  responses: []
