---
main:
  messages:
  - remember the <addressing modes> from the assembly chapter?
  - well... it's time to emulate them 😏
  - I made a quick reference for you
  - check out 📄  ~/docs/cpu/addressing_modes.en.md~
  run-after-messages: |
    store.dispatch.savedata.openFile("/docs/cpu/addressing_modes.en.md");
  responses:
  - I'll definitely need you to explain this a bit further [explain]

explain:
  messages:
  - yeah
  - you can see every addressing mode has an <input> and an <output>
  - ⬅️  the <input> is the argument (what follows the opcode, remember?)
  - in `JMP ($4080)` the <input> would be $4080
  - ➡️  the <output> is what the instructions end up actually receiving
  - (the `address` argument in your `JMP` instruction's `run(...)` function)
  - in this case, the <output> would be the result of performing a 16-bit read to address $4080
  responses:
  - not quite, what's that page boundary bug? 🐞 [pageboundary]

pageboundary:
  messages:
  - basically, the hardware unit was released with a bug in the "Indirect" mode
  - and if we want to emulate the hardware accurately... we have to also emulate the bugs 😅
  responses:
  - (*) can't I just fix the bug? [fix]
  - let's code this [letscode]

fix:
  messages:
  - you can, but you'd be breaking compatibility with some games that depend (whether accidentally or intentionally) on that bug
  responses:
  - ...pageboundary

letscode:
  messages:
  - actually I already coded some of these modes
  - so you only have to implement "Relative" and "Indirect"
  - you can grab the code from 📄  ~/docs/cpu/example_addressing_modes.js~ and continue from there!
  - 📚  implement the missing addressing modes
  - and export the object under the `addressingModes` key in ~/code/index.js~
  responses:
  - help me with the "Relative" mode 😅 [relative]
  - help me with the "Indirect" mode 😅 [indirect]

relative:
  messages:
  - 💡  remember that it takes an "offset" (a signed byte)
  - signed bytes can be tricky to understand for humans
  - they use the "Two's component" notation, which is explained briefly in ~/lib/byte.js~
  - for example, if the offset is ~-3~, you would receive a 253
  - you can convert that 253 to ~-3~ using the `toS8` method
  - 💡  also, to check for page crossing events, you will need `highByteOf`
  responses:
  - ...letscode

indirect:
  messages:
  - you have a full implementation in the doc file 😊
  - it's pseudocode, right, but you'll be able to make it work
  responses:
  - ...letscode
