---
main:
  messages:
  - a veces, los valores se representan usando más de 1 byte
  - p. ej. cuando una instrucción de CPU tiene una dirección de 16 bits como argumento
  - o al usar la instrucción `RTS` y la CPU tiene que restaurar [PC] desde la pila
  - en estos casos, se usa la convención <Little Endian> 🔌
  - "eso significa: el byte menos significativo (\"low byte\") se guarda primero, luego el más significativo (\"high byte\")"
  - |-
    📚  implementa este método en `CPUMemory`:
    **read16(address)**:
      __retorna un número de 16 bits usando los bytes de <address> (low byte) y <address>+1 (high byte)__
  - |-
    y estos dos métodos en `Stack`:
    **push16(value)**:
      __usa *push* primero con el "high byte", y luego con el "low byte"__
    **pop16()**:
      __retorna un número de 16 bits luego de hacer *pop* dos veces (primero el "low byte", luego el "high byte")__
  - 💡  ¡recuerda usar ~/lib/byte.js~!
  responses: []
