---
main:
  messages:
  - only two instructions left 🎉
  - "and one of them is pretty trivial: `NOP`"
  - "`NOP` means \"No Operation\", and it does nothing!"
  - game developers used this as a placeholder, or to introduce timing delays to synchronize their systems
  - so, last one is `BRK` which generates an <Interrupt Request>
  responses:
  - what's an interrupt? [interrupt]

interrupt:
  messages:
  - it's a signal that interrupts the current program in order to handle a specific event
  - when such event happens, the CPU saves its state ([PC] and flags) in the stack
  - and jumps to a well-known memory location (called "vector") associated with that event
  - "in the NEEES, there are 3 events:"
  - "🔁  <RESET>: Triggered when the system is turned on"
  - "📹  <NMI>: Triggered when the PPU finishes drawing a frame"
  - "✋  <IRQ>: Triggered after a `BRK` instruction"
  responses:
  - can you give me an example? 🤔 [example]

example:
  messages:
  - sure! imagine you're a game
  - you need to move your sprites when the PPU finishes drawing its current frame
  - to avoid doing it while it draws (causing glitches 💥 )
  - so, you put your sprite moving code in -for example- address $90CC
  - that will be the location of your <interrupt handler>
  - and then you "subscribe" to the <NMI> event by placing a pointer to $90CC in <NMI>'s vector (which is $FFFA/B)
  - (in Little Endian, so $FFFA holds $CC and $FFFB holds $90)
  responses:
  - what would happen when an <NMI> occurs? [nmi]

nmi:
  messages:
  - "in this example, when the <NMI> is triggered, the CPU will:"
  - 🧱  push [PC] and the flags onto the stack
  - 🏁  set ~I=1~, which disables user interrupts
  - 🧱  grab the value $90CC by reading $FFFA and $FFFB (<NMI>'s vector)
  - 🦘  jump to $90CC
  - 🚲  consume 7 cycles while doing all this
  - then, the interrupt handler will move the sprites and run `RTI` ("Return from Interrupt") to restore the previous state
  responses:
  - (*) what about the 7-cycle stuff? 🚲 [cycle]
  - (*) what's the purpose of the I flag? 🏁 [iflag]
  - great! I think I'm ready to implement it 😎 [implement]

cycle:
  messages:
  - that's time it takes to process an interrupt 🕖
  - we didn't talk much about cycles so far
  - I've only made you add two mysterious properties to the `CPU` class, remember?
  - those called `cycles` and `extraCycles`
  - I'll explain this further later, I promise 😅
  responses:
  - ...nmi

iflag:
  messages:
  - it's the "Interrupt Disable" flag, and as the name says, it disables interrupts
  - the systems sets ~I=1~ so interrupts handlers don't get... hmm... interrupted 😅
  - |-
    the thing is... only <IRQ> events can be disabled
    <RESET> can't be ignored for obvious reasons
    <NMI> stands for "Non-maskable interrupt" and it's very important, so it can't be masked (aka "disabled")
  responses:
  - ...nmi

implement:
  messages:
  - awesome
  - we'll model interrupts as `{ id, vector }` objects
  - check out ~/lib/interrupts.js~
  - |-
    📚  add this method to your `CPU`:
    **interrupt(interrupt, withBFlag = false)**:
      __-> if interrupt.id === "IRQ" and I=1, returns 0
        (the interrupt is ignored)
      -> pushes [PC] onto the stack
      -> pushes the flags onto the stack
        (if <withBFlag> is true, the flags byte should have bit 4 on)
      -> increments 7 cycles (this.cycles += 7)
      -> sets I=1 in the flags register
      -> sets [PC] = the result of reading the addresses (interrupt.vector) and (interrupt.vector + 1) in Little Endian
        (remember that you have a *read16* method)
      -> returns 7__
  run-after-messages: |
    store.dispatch.savedata.openFile("/lib/interrupts.js");
  responses:
  - and BRK? [brk]

brk:
  messages:
  - you can implement the `BRK` instruction just by calling `cpu.interrupt(interrupts.IRQ, true)`
  responses: []
