---
main:
  messages:
  - solo quedan dos instrucciones 🎉
  - "y una de ellas es bastante trivial: `NOP`"
  - "`NOP` significa \"No Operation\", ¡y no hace nada!"
  - los desarrolladores de juegos usaban esto como un espacio reservado, o para introducir retrasos de tiempo para sincronizar sus sistemas
  - así que, la última es `BRK`, que genera un <Pedido de Interrupción>
  responses:
  - ¿qué es una interrupción? [interrupt]

interrupt:
  messages:
  - es una señal que interrumpe el programa actual para manejar un evento específico
  - cuando tal evento ocurre, la CPU guarda su estado ([PC] y banderas) en la pila
  - y salta a una dirección de memoria conocida (llamada "vector") asociada a ese evento
  - "en la NEEES, hay 3 eventos:"
  - "🔁  <RESET>: Disparado cuando el sistema se enciende"
  - "📹  <NMI>: Disparado cuando la PPU termina de dibujar un frame"
  - "✋  <IRQ>: Disparado luego de una instrucción `BRK`"
  responses:
  - ¿puedes darme un ejemplo? 🤔 [example]

example:
  messages:
  - ¡sí! imagina que eres un juego
  - necesitas mover tus sprites cuando la PPU termina de dibujar su frame actual, para evitar hacerlo mientras dibuja (causando glitches 💥 )
  - así que, pones tu código que mueve sprites en -por ejemplo- la dirección $90CC
  - esa será la ubicación de tu <manejador de interrupciones>
  - y luego te "suscribes" al evento <NMI> poniendo un puntero a $90CC en el vector de <NMI> (que es $FFFA/B)
  - (en Little Endian, por lo que $FFFA guarda $CC y $FFFB guarda $90)
  responses:
  - ¿qué pasaría cuando un <NMI> ocurre? [nmi]

nmi:
  messages:
  - "en este ejemplo, cuando un <NMI> es disparado, la CPU:"
  - 🧱  pone [PC] y las banderas en la pila
  - 🏁  asigna ~I=1~, que desactiva las interrupciones del usuario
  - 🧱  toma el valor $90CC de leer $FFFA y $FFFB (el vector de <NMI>)
  - 🦘  salta a $90CC
  - 🚲  consume 7 ciclos haciendo todo esto
  - luego, el manejador de interrupciones moverá los sprites y ejecutará `RTI` ("Return from Interrupt") para restaurar el estado anterior
  responses:
  - (*) ¿qué es eso de los 7 ciclos? 🚲 [cycle]
  - (*) ¿cuál es el propósito de la bandera I? 🏁 [iflag]
  - ¡genial! creo que ya podría implementarlo 😎 [implement]

cycle:
  messages:
  - es el tiempo que toma procesar una interrupción 🕖
  - no hablamos mucho de ciclos hasta ahora
  - solo te hice agregar unas propiedades misteriosas en la clase `CPU`, ¿recuerdas?
  - esas llamadas `cycles` y `extraCycles`
  - voy a explicar más esto luego, lo prometo 😅
  responses:
  - ...nmi

iflag:
  messages:
  - es la bandera "Interrupt Disable", y como su nombre indica, desactiva las interrupciones
  - el sistema asigna ~I=1~ para que los manejadores de interrupciones no sean... mmm... interrumpidos 😅
  - |-
    la cosa es que... solo los eventos <IRQ> se pueden desactivar
    <RESET> no puede ser ignorada por obvias razones
    <NMI> quiere decir "Non-maskable interrupt" y es muy importante, por lo que no puede ser "masked" (o sea, desactivada)
  responses:
  - ...nmi

implement:
  messages:
  - genial
  - vamos a modelar las interrupciones como objetos `{ id, vector }`
  - revisa 📄  ~/lib/interrupts.js~
  - |-
    📚  agrega este método a tu `CPU`:
    **interrupt(interrupt, withBFlag = false)**:
      __-> si interrupt.id === "IRQ" y I=1, retorna 0
        (la interrupción es ignorada)
      -> pone [PC] en la pila
      -> pone las banderas en la pila
        (si <withBFlag> es true, el byte de banderas tendría que tener el bit 4 encendido)
      -> incrementa 7 ciclos (this.cycles += 7)
      -> asigna I=1 en el registro de banderas
      -> asigna [PC] = al resultado de leer las direcciones (interrupt.vector) y (interrupt.vector + 1) en Little Endian
        (recuerda que tienes un método *read16*)
      -> retorna 7__
  run-after-messages: |
    store.dispatch.savedata.openFile("/lib/interrupts.js");
  responses:
  - ¿y BRK? [brk]

brk:
  messages:
  - puedes implementar la instrucción `BRK` solo llamando `cpu.interrupt(interrupts.IRQ, true)`
  responses: []
